<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Vialundskolans MoodCam (v.1.3.9)</title>
  <link rel="icon" href="data:,">
<style>
  :root{--bg:#0b0f14;--fg:#e7effa;--panel:#0f172a;--panel2:#111827;--border:#1f2937;--accent:#22c55e}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,sans-serif}
  #stage{display:grid;grid-template-columns:1fr;gap:16px;height:100vh;align-items:center;justify-items:center;padding:12px}

  .topbar{position:fixed;top:10px;left:10px;display:flex;gap:8px;z-index:10}
  .btn{background:var(--panel2);border:1px solid var(--border);color:var(--fg);padding:8px 12px;border-radius:8px;cursor:pointer}
  .btn:disabled{opacity:.5;cursor:not-allowed}

  .layer-wrap{position:relative;display:inline-block;border-radius:12px;overflow:hidden;box-shadow:0 12px 36px rgba(0,0,0,.5);max-width:96vw;max-height:86vh}

  /* ‚ùóSpegelv√§nd **composite** (det anv√§ndaren ser), inte <video> */
  .layer-wrap.mirror #composite { transform: scaleX(-1); }

  /* R√•video h√•lls g√∂md men driver storlek & √§r k√§lla till analyser */
  #video{
    visibility:hidden;
    width:100%; height:auto; position:relative; z-index:0;
  }
  #composite{ position:absolute; inset:0; width:100%; height:100%; z-index:0; }
  #overlay{ position:absolute; inset:0; width:100%; height:100%; pointer-events:none; z-index:1; }

  #meterWrap{
    position:absolute; left:50%; transform:translateX(-50%); bottom:0;
    background:var(--panel); border:1px solid var(--border);
    border-bottom-left-radius:0; border-bottom-right-radius:0;
    border-top-left-radius:10px; border-top-right-radius:10px;
    padding:6px 10px; width:min(360px,70%); z-index:2;
  }
  #meterBar{position:relative;height:8px;background:#0d1218;border-radius:6px;overflow:hidden;border:1px solid var(--border)}
  #meterFill{height:100%;width:0%;background:linear-gradient(90deg,#2dd4bf,#22c55e)}
  .meterVal{position:absolute;right:6px;top:-16px;opacity:.85}
  .small{font-size:12px;opacity:.8}

  #settings{display:none;position:fixed;right:12px;top:52px;width:360px;max-height:85vh;overflow:auto;background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:12px 12px 8px;z-index:20}
  #settings h3{margin:6px 0 8px 0;font-size:16px}
  #settings .row{display:flex;justify-content:space-between;align-items:center;margin:8px 0}
  #settings label{font-size:14px}

  details{border:1px dashed var(--border);border-radius:8px;padding:6px;margin-top:8px}
  summary{cursor:pointer}
  .desc{font-size:12px;opacity:.75;margin:4px 0 0}
  input[type="range"]{width:190px}
  .two-col{display:grid;grid-template-columns:auto 1fr;gap:8px;align-items:center}
  .hud{position:fixed;left:14px;bottom:14px;font-size:12px;opacity:.7}
</style>
<script> 
  /* ---------- Konsolfilter ---------- */
  const ORIG_CONSOLE = { info: console.info, warn: console.warn, log: console.log };
  const NOISE_PATTERNS = [/already been set/i,/backend was already registered/i,/kernel .* already registered/i,/Reusing existing backend factory/i];
  console.warn = (...a)=>{ const s=(a||[]).join(' '); if (NOISE_PATTERNS.some(r=>r.test(s))) return; ORIG_CONSOLE.warn.apply(console,a); };
  console.info = (...a)=>{ const s=(a||[]).join(' '); if (NOISE_PATTERNS.some(r=>r.test(s))) return; ORIG_CONSOLE.info.apply(console,a); };
  </script>
  <!-- Libs -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.21.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@4.21.0/dist/tf-backend-wasm.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api/dist/face-api.min.js"></script>
  <script defer src="./vendor/mediapipe/selfie_segmentation/selfie_segmentation.js"></script>

</head>
<body>
  <div class="topbar">
    <button id="start" class="btn">Starta kamera</button>
    <button id="settingsBtn" class="btn" aria-label="√ñppna inst√§llningar">Settings</button>
  </div>

  <div id="stage">
    <div class="layer-wrap" id="wrap">
      <video id="video" autoplay muted playsinline></video>
      <canvas id="composite"></canvas>
      <canvas id="overlay"></canvas>

      <div id="meterWrap">
        <div id="meterBar">
          <div id="meterFill"></div>
          <span id="meterVal" class="small meterVal" aria-live="polite">0</span>
        </div>
        <div class="small" style="margin-top:2px">
          Moodm√§tare ‚Äì B√∂rjar √∂ka efter <em>1s</em>, s√• SMILE üòÑ
        </div>
      </div>

      <video id="ghost" playsinline muted></video>
    </div>
  </div>

  <div id="settings">
    <h3>Settings</h3>
    <div class="row">
      <label for="camSel">Kamera</label>
      <select id="camSel" class="btn" style="width:220px"></select>
    </div>
    <div class="row">
      <label for="conf">Konfidens (etikett)</label>
      <input id="conf" type="range" min="0.2" max="0.9" step="0.05" value="0.40">
    </div>
    <div class="row">
      <label for="inputSize">Detector size</label>
      <input id="inputSize" type="range" min="224" max="512" step="32" value="320">
    </div>
    <div class="row">
      <label for="score">Detektor-tr√∂skel</label>
      <input id="score" type="range" min="0.40" max="0.80" step="0.01" value="0.60">
    </div>

    <details>
      <summary>Peppande one-liners</summary>
      <div class="row" style="margin-top:8px">
        <label>Aktivera</label><input type="checkbox" id="peppToggle" checked>
      </div>
      <div class="row">
        <label for="peppCat">Kategori</label>
        <select id="peppCat" class="btn" style="width:220px"></select>
      </div>
      <p class="desc">Visas i varje ansiktsruta, l√•ses per person tills de l√§mnar bild. Kategorier och texter l√§ses fr√•n <code>pepp.json</code>.</p>
    </details>

    <details>
      <summary>Overlays & teman</summary>
      <div class="row">
        <!-- ‚õîÔ∏è AV fr√•n start -->
        <label>Aktivera overlays</label><input type="checkbox" id="overlayToggle">
      </div>
      <div class="row">
        <label for="themeSel">Tema</label>
        <select id="themeSel" class="btn" style="width:220px"></select>
      </div>
      <div class="row"><label>Hattar</label><input type="checkbox" id="ovHats"></div>
      <div class="row"><label>Glas√∂gon</label><input type="checkbox" id="ovGlasses" checked></div>
      <div class="row"><label>√ñgon</label><input type="checkbox" id="ovEyes"></div>
      <div class="row"><label>Munnar</label><input type="checkbox" id="ovMouth"></div>
      <div class="row"><label>Sk√§gg</label><input type="checkbox" id="ovBeard"></div>
      <div class="row"><label>Visa ansiktsruta</label><input type="checkbox" id="showBox"></div>
      <p class="desc">Tema anger *vilka filer*; passform kommer fr√•n <code>img/assets/meta.json</code>.</p>
    </details>

    <details>
      <summary>Kamera ‚Äì bild (filter)</summary>
      <div class="two-col">
        <label for="fBrightness">Ljusstyrka</label><input id="fBrightness" type="range" min="50" max="150" step="1" value="100">
        <label for="fContrast">Kontrast</label><input id="fContrast"   type="range" min="50" max="150" step="1" value="100">
        <label for="fSaturate">M√§ttnad</label><input id="fSaturate"    type="range" min="0"  max="200" step="1" value="100">
        <label for="fHue">Ton (¬∞)</label><input id="fHue"              type="range" min="-180" max="180" step="1" value="0">
        <label for="fTemp">F√§rgtemperatur</label><input id="fTemp" type="range" min="-50" max="50" step="1" value="0">
        <label for="mirrorX">Spegelv√§nd bild</label><input id="mirrorX" type="checkbox" checked>
      </div>
      <div class="row"><button id="filtersReset" class="btn">√Öterst√§ll</button></div>
      <p class="desc">P√•verkar bara visningen (inte detekteringen).</p>
    </details>

    <details>
      <summary>Bes√∂kslogg</summary>
      <div class="row" style="margin-top:8px">
        <button id="dlLog" class="btn">Ladda ner CSV</button>
        <button id="clearLog" class="btn" style="background:#581c1c;border-color:#7f1d1d">Nollst√§ll</button>
      </div>
      <p id="logInfo" class="small"></p>
    </details>

    <details>
      <summary>Bakgrundseffekt</summary>
      <!-- ‚õîÔ∏è AV fr√•n start -->
      <div class="row"><label>Aktivera</label><input type="checkbox" id="ghostToggle"></div>
      <div class="row">
        <label for="ghostMode">Frekvens</label>
        <select id="ghostMode" class="btn" style="width:220px">
          <option value="rare" selected>S√§llan</option>
          <option value="sometimes">Ibland</option>
          <option value="often">Ofta</option>
        </select>
      </div>
      <div class="row">
        <label for="ghostFacesOnly">Bara n√§r n√•gon syns</label><input type="checkbox" id="ghostFacesOnly" checked>
      </div>
      <div class="row">
        <label for="ghostBgAlpha">Bakgrundsgenomskinlighet</label>
        <input id="ghostBgAlpha" type="range" min="60" max="100" step="1" value="88">
      </div>
      <div class="row">
        <button id="ghostNow" class="btn">Spela sp√∂ke nu üëª</button>
      </div>
      <p class="desc">Spelar korta klipp i bakgrunden. F√∂rgrunden maskas ovanp√• s√• personer syns normalt.</p>
    </details>

    <details>
      <summary>Moodm√§tare ‚Äì m√•l</summary>
      <div class="row">
        <label for="goalSec">M√•l (sekunder glad-tid)</label>
        <input id="goalSec" type="range" min="300" max="3600" step="60" value="300">
      </div>
      <p class="small">Nuvarande m√•l: <span id="goalLabel">300</span> s</p>
    </details>
  </div>

  <div class="hud">Allt k√∂rs lokalt i datorn. /Kristoffer</div>

<script>
const DEBUG = false;

// ---- DEBUG HELPERS ----
let __frame = 0;
const every = (n, fn) => { __frame++; if (__frame % n === 0) fn(); };
const tag = (t, ...a) => console.log(`[${t}]`, ...a);


/* ---------- Konstanter & state ---------- */
const EMO_SV = { angry:"Arg", disgusted:"√Ñcklad", fearful:"R√§dd", happy:"Glad", neutral:"Neutral", sad:"Ledsen", surprised:"F√∂rv√•nad" };
const EMO_EMOJI = { angry:"üò°", disgusted:"ü§¢", fearful:"üò®", happy:"üòÑ", neutral:"üòê", sad:"üò¢", surprised:"üòÆ" };
const EMO_COLOR = { happy:"#28c728", angry:"#2a2ae0", sad:"#c07800", surprised:"#c0c000", fearful:"#00b4b4", disgusted:"#00a078", neutral:"#b0b0b0" };
const UI = { labelFontSize:16, labelPad:4, pepFontSize:16, pepPad:4, faceBoxWidth:2 };

let EMO_CONF_MIN = 0.40;
let DETECTOR_SIZE = 320;
let DETECTOR_SCORE = 0.60;

let peppEnabled = true;
let peppCat = 'all';
let PEPP = {};
let PEPP_KEYS = [];

const THEMES = ["Aktivt (img/manifest.json)","halloween","jul","sommar","skolstart","test"];
let selectedTheme = THEMES[0];

let overlaysEnabled = false;
/* ‚ùóStartl√§ge synkas i init() fr√•n checkboxar ‚Äì defaulta allt till false h√§r */
const overlayUse = { hats:false, glasses:false, eyes:false, mouth:false, beard:false };

let overlayManifest = null;
const imgCache = new Map();

let assetMeta = {};
async function loadAssetMeta(){
  try{
    const r = await fetch('./img/assets/meta.json', {cache:'no-store'});
    if (r.ok) assetMeta = await r.json();
  }catch(e){ if (DEBUG) console.warn('[MoodCam] assets/meta.json saknas/ol√§slig', e); }
}

let LANDMARKS_AVAILABLE = false;

let video, overlay, ctx, currentStream=null;
let composite, compCtx; // f√∂r sp√∂k-komposit
let ghostEl;

/* Tracks */
const tracks = [];
let nextId = 1;

let lastFrameTime = performance.now();

/* Mood-meter */
let HAPPY_PERSON_SECONDS = 0;
let METER_GOAL_SECONDS = 300;
let meterShown = 0;
const METER_EASE = 0.07;
const HAPPY_WARMUP_SECONDS = 1; // ‚¨ÖÔ∏è √§ndrat fr√•n 3 till 1
const CONTRIB_WEIGHT_BY_CONF = true;

const RESET_H = 19, RESET_M = 30;

/* Jitter-filter */
const POSE_ALPHA = 0.15;
const BBOX_POS_ALPHA  = 0.35;
const BBOX_SIZE_ALPHA = 0.75;
const ema = (prev, next, a)=> (prev==null? next : prev + a*(next - prev));

/* Spegeltillst√•nd */
let MIRROR = true;

/* Visa/d√∂lj ansiktsruta ‚Äì default: osynlig */
let SHOW_FACE_BOX = false;

/* Adaptiv input */
const FRAME_OPTS = { ADAPTIVE_INPUT: true, MANY_FACES_THRESHOLD: 3, LOW_INPUT_SIZE: 288 };
let FRAME_I = 0;

/* Logg */
const visitorsByDay = JSON.parse(localStorage.getItem('moodcam.visitors') || '{}');
updateLogInfo();
const AGE_SMOOTH_WINDOW_MS = 10_000;

/* ---------- Hj√§lp ---------- */
function todayKey(){ const d=new Date(); return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`; }
function scheduleResetIfNeeded(){ const now=new Date(); const reset=new Date(); reset.setHours(RESET_H, RESET_M, 0, 0); if (Math.abs(now-reset)<1000){ HAPPY_PERSON_SECONDS=0; meterShown=0; } }
function iou(a,b){
  const [ax,ay,aw,ah] = a, [bx,by,bw,bh] = b;
  const x1 = Math.max(ax, bx), y1 = Math.max(ay, by);
  const x2 = Math.min(ax + aw, bx + bw), y2 = Math.min(ay + ah, by + bh);
  const inter = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
  const union = aw * ah + bw * bh - inter;
  return union > 0 ? inter / union : 0;
}

function mirrorX(x, w=0){ return MIRROR ? (overlay.width - (x + w)) : x; }

function drawLabel(x,y,text){
  ctx.font = `${UI.labelFontSize}px system-ui`; ctx.textAlign='left'; ctx.textBaseline='alphabetic';
  const pad=UI.labelPad, h=UI.labelFontSize*1.2, w=ctx.measureText(text).width;
  ctx.fillStyle='rgba(0,0,0,0.85)'; ctx.fillRect(x-pad,y-h-pad,w+pad*2,h+pad*2);
  ctx.fillStyle='#fff'; ctx.fillText(text,x,y);
}
function drawCenteredBottom(x,y,w,h,text){
  if (!text) return;
  ctx.font = `${UI.pepFontSize}px system-ui`; ctx.textAlign='left'; ctx.textBaseline='alphabetic';
  const pad=UI.pepPad, htxt=UI.pepFontSize*1.2, tw=ctx.measureText(text).width, cx=x+w/2-tw/2, cy=y+h-8;
  ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(cx-pad,cy-htxt-pad,tw+pad*2,htxt+pad*2);
  ctx.fillStyle='#fff'; ctx.fillText(text,cx,cy);
}
function syncOverlaySize(){
  overlay.width  = video.videoWidth;
  overlay.height = video.videoHeight;
  composite.width  = video.videoWidth;
  composite.height = video.videoHeight;

  const wrapEl = document.getElementById('wrap');
  const rect = wrapEl.getBoundingClientRect();
  overlay.style.width  = rect.width + 'px';
  overlay.style.height = rect.height + 'px';
  composite.style.width  = rect.width + 'px';
  composite.style.height = rect.height + 'px';
}

/* üîß Canvas-filter (s√• reglagen p√•verkar bilden som syns) */
let CAM_FILTER = 'none';
function buildCamFilterString() {
  const b = +fBrightness.value;
  const c = +fContrast.value;
  const s = +fSaturate.value;
  const h = +fHue.value;
  const t = +fTemp.value;
  const temp =
    t !== 0
      ? ` sepia(${Math.max(0, t) * 0.006}) hue-rotate(${(t * 1.2).toFixed(1)}deg) saturate(${(100 + t * 0.2).toFixed(1)}%)`
      : '';
  return `brightness(${b}%) contrast(${c}%) saturate(${s}%) hue-rotate(${h}deg)` + temp;
}
function drawVideoWithFilter(ctx, dx, dy, dw, dh) {
  ctx.save();
  ctx.filter = CAM_FILTER;
  ctx.drawImage(video, dx, dy, dw, dh);
  ctx.restore();
}

/* üîß √Ñndrat: d√∂lj √•ldern tills glidande medelv√§rde finns */
function getSmoothedAge(track, now, latestAge){
  if (latestAge!=null && !Number.isNaN(latestAge)) track.ageHist.push({t:now,a:latestAge});
  const cutoff=now-AGE_SMOOTH_WINDOW_MS; while (track.ageHist.length && track.ageHist[0].t<cutoff) track.ageHist.shift();
  // Visa inget f√∂rr√§n vi har ett f√∂nster med historik
  if ((now - track.created) < AGE_SMOOTH_WINDOW_MS) return null;
  if (!track.ageHist.length) return null;
  const avg=track.ageHist.reduce((s,p)=>s+p.a,0)/track.ageHist.length; return Math.round(avg);
}

/* ---------- Pepp (extern) ---------- */
async function loadPepp(){
  try{
    const r = await fetch('./pepp.json', {cache:'no-store'});
    if(!r.ok) throw new Error('Kunde inte l√§sa pepp.json');
    const data = await r.json();
    const ok = Object.fromEntries(
      Object.entries(data).filter(([k,v]) => Array.isArray(v))
                          .map(([k,v]) => [k, v.filter(x => typeof x === 'string')])
    );
    PEPP = ok; PEPP_KEYS = Object.keys(PEPP);
    populatePeppCategories();
  }catch(e){
    console.error('[MoodCam] pepp.json fel:', e);
    PEPP = {}; PEPP_KEYS = [];
    populatePeppCategories();
  }
}
function populatePeppCategories(){
  const sel = document.getElementById('peppCat');
  sel.innerHTML = '';
  if (PEPP_KEYS.length){
    const oAll=document.createElement('option'); oAll.value='all'; oAll.textContent='Alla'; sel.appendChild(oAll);
  }
  PEPP_KEYS.sort().forEach(k=>{
    const o=document.createElement('option'); o.value=k; o.textContent=k; sel.appendChild(o);
  });
  peppCat = (PEPP_KEYS.length ? 'all' : '');
  sel.value = peppCat || (PEPP_KEYS[0] || '');
}
function randomPepp(){
  if (!peppEnabled || !PEPP_KEYS.length) return '';
  const pool = (peppCat === 'all' || !peppCat) ? PEPP_KEYS.flatMap(k => PEPP[k] || []) : (PEPP[peppCat] || []);
  if (!pool.length) return '';
  return pool[Math.floor(Math.random()*pool.length)];
}

/* --------- Overlays & teman --------- */
async function loadOverlayManifest(themeName){
  overlayManifest=null;
  let url = (!themeName || themeName === THEMES[0]) ? './img/manifest.json' : `./img/tema/${themeName}/manifest.json`;
  try{
    const resp=await fetch(url,{cache:'no-store'}); if(!resp.ok) return;
    const data=await resp.json();
    if (!data.facial_hair && data.faceal_hair) data.facial_hair = data.faceal_hair;
    for (const cat of ["hats","glasses","eyes","mouth","facial_hair"]) {
      const src = data[cat] || [];
      data[cat] = src.map(it => (typeof it === 'string' ? { file: it } : it));
    }
    overlayManifest = data;
    const toLoad=[];
    for (const cat of ["hats","glasses","eyes","mouth","facial_hair"]) {
      (data[cat]||[]).forEach(item=>{
        const path = `./img/${item.file}`;
        if(!imgCache.has(path)){
          const im = new Image();
          im.src = path;
          imgCache.set(path, im);
          toLoad.push(im.decode?.() ?? new Promise(r=>{im.onload=r;im.onerror=r;}));
        }
      });
    }
    await Promise.all(toLoad);
  } catch(e){ if (DEBUG) console.warn('[MoodCam] Overlay manifest kunde inte laddas', e); }
}
function choiceWeighted(arr){
  if(!arr || !arr.length) return null;
  const weights = arr.map(o => (o.prob ?? 1));
  const sum = weights.reduce((a,b)=>a+b,0);
  let r = Math.random()*sum;
  for (let i=0;i<arr.length;i++){ r -= weights[i]; if (r <= 0) return arr[i]; }
  return arr[arr.length-1];
}
function assignEffects(track){
  if(!overlaysEnabled || !overlayManifest){ track.effects=null; return; }
  const e={};
  if (overlayUse.hats) e.hat = choiceWeighted(overlayManifest.hats) || null;
  if (overlayUse.eyes && overlayUse.glasses) {
    const pickEyes = Math.random() < 0.5;
    if (pickEyes) e.eyes = choiceWeighted(overlayManifest.eyes) || null;
    else          e.glass = choiceWeighted(overlayManifest.glasses) || null;
  } else {
    if (overlayUse.eyes)    e.eyes  = choiceWeighted(overlayManifest.eyes) || null;
    if (overlayUse.glasses) e.glass = choiceWeighted(overlayManifest.glasses) || null;
  }
  if (overlayUse.mouth) e.mouth = choiceWeighted(overlayManifest.mouth) || null;
  if (overlayUse.beard) e.beard = choiceWeighted(overlayManifest.facial_hair) || null;
  track.effects = e;
}

/* ---- Pose sanity (bbox-medveten) ---- */
function isValidPose(p, box){
  if (!p || !box) return false;
  const {x, y, width: w, height: h} = box;
  const ok = v => Number.isFinite(v);
  if (!ok(p.eyeCx)||!ok(p.eyeCy)||!ok(p.eyeD)) return false;
  const ex = p.eyeCx - x; const ey = p.eyeCy - y;
  const minEyeD = Math.max(6, Math.min(w,h)*0.06);
  const maxEyeD = Math.min(w*0.9, Math.min(w,h)*0.8);
  if (!(p.eyeD > minEyeD && p.eyeD < maxEyeD)) return false;
  if (ok(p.mouthW) && !(p.mouthW > minEyeD*0.6 && p.mouthW < w*1.2)) return false;
  if (!(ex >= -w*0.2 && ex <= w*1.2 && ey >= -h*0.2 && ey <= h*1.2)) return false;
  return true;
}
function defaultFitForFile(path){
  if (path.startsWith('assets/glasses/'))     return 'glasses';
  if (path.startsWith('assets/eyes/'))        return 'eyes';
  if (path.startsWith('assets/mouth/'))       return 'mouth';
  if (path.startsWith('assets/facial_hair/')) return 'beard';
  if (path.startsWith('assets/hats/'))        return 'hat';
  return 'bbox';
}
function drawItem(meta, track, x,y,w,h){
  if(!meta) return;
  const path = `./img/${meta.file}`;
  const img = imgCache.get(path); if(!img) return;
  const iw = (img.width || img.naturalWidth || 1);
  const ih = (img.height || img.naturalHeight || 1);
  const mAsset = assetMeta[meta.file] || {};
  const cfg = { ...meta, ...mAsset };
  const fit = (cfg.fit || defaultFitForFile(cfg.file));
  const flipX = !!cfg.flipX;
  const rotWithEyes = (cfg.rot !== false);
  if (!track.usePose) return;
  const p = track.pose;
  let eyeC = {x:p.eyeCx, y:p.eyeCy};
  let eyeD = p.eyeD;
  if (!Number.isFinite(eyeC.x) || !Number.isFinite(eyeC.y) || !Number.isFinite(eyeD)) return;
  let angle= p.angle || 0;
  let mouthC = (p.mouthCx!=null && p.mouthCy!=null) ? {x:p.mouthCx, y:p.mouthCy} : {x:eyeC.x, y:eyeC.y + eyeD*0.6};
  const mouthW = p.mouthW || eyeD*0.9;
  const faceW  = p.faceW  || w;
  if (MIRROR){ eyeC = { x: overlay.width - eyeC.x, y: eyeC.y }; mouthC = { x: overlay.width - mouthC.x, y: mouthC.y }; angle = -angle; }
  let cx, cy, refW, defWF=1.0, defY=0, defX=0;
  if (fit==='eyes' || fit==='glasses'){ cx=eyeC.x; cy=eyeC.y; refW=eyeD; defWF=(fit==='eyes')?2.2:2.0; defY=(fit==='eyes')?0.15:0.05; }
  else if (fit==='mouth'){ cx=mouthC.x; cy=mouthC.y; refW=mouthW; defWF=1.3; }
  else if (fit==='beard'){ cx=mouthC.x; cy=mouthC.y + eyeD*0.55; refW=faceW; defWF=0.9; defY=0.05; }
  else if (fit==='hat'){ cx=eyeC.x; cy=eyeC.y - eyeD*0.9; refW=faceW; defWF=1.1; defY=-0.15; }
  else { return; }
  const wf = (cfg.wFactor ?? defWF);
  const drawW = refW * wf;
  const drawH = drawW * (ih/iw);
  const dx = (cfg.xOffset || defX) * refW;
  const dy = ((cfg.yOffset !== undefined ? cfg.yOffset : defY)) * refW;
  ctx.save();
  if (rotWithEyes){
    ctx.translate(cx + dx, cy + dy);
    if (flipX) ctx.scale(-1,1);
    ctx.rotate(angle);
    ctx.drawImage(img, -drawW/2, -drawH/2, drawW, drawH);
  } else {
    const px = cx + dx - drawW/2, py = cy + dy - drawH/2;
    if (flipX){ ctx.translate(px+drawW/2, py+drawH/2); ctx.scale(-1,1); ctx.drawImage(img,-drawW/2,-drawH/2,drawW,drawH); }
    else ctx.drawImage(img, px, py, drawW, drawH);
  }
  ctx.restore();
}
function drawEffects(track,x,y,w,h){
  if(!overlaysEnabled || !track.effects) return;
  const e=track.effects;
  if (e.eyes)  drawItem(e.eyes,  track, x,y,w,h);
  if (e.glass) drawItem(e.glass, track, x,y,w,h);
  if (e.mouth) drawItem(e.mouth, track, x,y,w,h);
  if (e.beard) drawItem(e.beard, track, x,y,w,h);
  if (e.hat)   drawItem(e.hat,   track, x,y,w,h);
}

/* ---------- Kamera ---------- */
async function listCams(defaultIndex=0){
  const sel = document.getElementById('camSel');
  sel.innerHTML = '';
  try{
    const devices = (await navigator.mediaDevices.enumerateDevices()).filter(d => d.kind === 'videoinput');
    devices.forEach((d,i)=>{
      const o=document.createElement('option'); o.value=d.deviceId||''; o.textContent=d.label||`Kamera ${i+1}`; sel.appendChild(o);
    });
    if (!sel.value && devices.length) sel.selectedIndex = Math.min(defaultIndex, devices.length-1);
  }catch(e){ if (DEBUG) console.warn('[MoodCam] enumerateDevices fel', e); }
}
async function startCamera(deviceId){
  try{
    if (currentStream) currentStream.getTracks().forEach(t => t.stop());
    const base = { width:{ideal:1280}, height:{ideal:720}, frameRate:{ideal:30}, facingMode:'user' };
    const constraints = { audio:false, video: deviceId ? { ...base, deviceId:{ exact: deviceId } } : base };
    currentStream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = currentStream;
    await new Promise(r=>{ const f=()=>{video.removeEventListener('loadedmetadata',f); r();}; if(video.readyState>=1) r(); else video.addEventListener('loadedmetadata',f); });
    await video.play().catch(()=>{});
    syncOverlaySize();
    return true;
  }catch(err){
    console.error('[MoodCam] getUserMedia failed', err);
    alert('Kunde inte starta kameran.\n' + (err.name?`${err.name}: `:'') + (err.message||'Ok√§nt fel.') + '\nTips: k√∂r √∂ver HTTPS/localhost och st√§ng andra appar som anv√§nder kameran.');
    return false;
  }
}

/* ---------- Modeller ---------- */
let modelsPromise=null;
function ensureModelsLoading(){
  if (modelsPromise) return modelsPromise;
  modelsPromise = (async ()=>{
    console.info('[MoodCam] Laddar modeller ‚Ä¶');
    console.time('[MoodCam] Modeller klara');
    try{
      const base='./models/';
      await faceapi.nets.tinyFaceDetector.load(base);
      await faceapi.nets.faceExpressionNet.load(base);
      await faceapi.nets.ageGenderNet.load(base);
      try{
        await faceapi.nets.faceLandmark68Net.load(base);
        LANDMARKS_AVAILABLE=true;
        console.info('[MoodCam] Landmarks aktiverade');
      }catch(e){
        LANDMARKS_AVAILABLE=false;
        if (DEBUG) console.warn('[MoodCam] Landmarks kunde inte laddas:', e);
      }
      console.timeEnd('[MoodCam] Modeller klara');
      return true;
    }catch(e){
      console.error('[MoodCam] Kunde inte l√§sa in modeller', e);
      alert('Kunde inte l√§sa in AI-modellerna fr√•n /models/. Kontrollera att mappen /models/ finns och att filerna √§r √•tkomliga.');
      return false;
    }
  })();
  return modelsPromise;
}

/* ---------- Sp√∂k-komposit ---------- */
let ghostEnabled = false;           // ‚õîÔ∏è AV fr√•n start
let ghostFacesOnly = true;
let ghostMode = 'rare';
let ghostAvgSec = 3600;
let ghostBgAlpha = 0.88;

const GHOST_CLIPS = ['ghosts/test.mp4'];

let seg=null, segReady=false, latestMask=null;
let playingGhost=false, lastGhostTs=0;
let minGapMs=120000;

function modeToAvgSec(m){ if (m==='rare') return 3600; if (m==='often') return 600; return 1800; }

function setupSegmentation(){
  return new Promise((resolve) => {
    try {
      const SegClass =
        (window.SelfieSegmentation && window.SelfieSegmentation.SelfieSegmentation) ||
        window.SelfieSegmentation;

      if (typeof SegClass !== 'function') {
        console.warn('[Seg] SelfieSegmentation saknas/ok√§nt API ‚Äì k√∂r utan mask.');
        seg = null; segReady = false; latestMask = null;
        return resolve();
      }

      seg = new SegClass({
        locateFile: (file) => `./vendor/mediapipe/selfie_segmentation/${file}`
      });

      seg.setOptions({ modelSelection: 1 });
      if (typeof seg.initialize === 'function') seg.initialize().then(
        ()=> tag('Seg', 'initialize() klar')
      ).catch(e=> console.warn('[Seg] initialize() fel', e));

      seg.onResults((res) => {
        latestMask = (res && res.segmentationMask) ? res.segmentationMask : null;
        every(30, ()=> tag('Seg', 'mask', !!latestMask, latestMask?.width, latestMask?.height));
      });

      segReady = true;
      tag('Seg', 'redo:', segReady);
      resolve();
    } catch (e) {
      console.warn('[Seg] Init-fel, k√∂r utan mask:', e);
      seg = null; segReady = false; latestMask = null;
      resolve();
    }
  });
}

function pickGhost(){ return GHOST_CLIPS[Math.floor(Math.random()*GHOST_CLIPS.length)]; }
async function playGhostOnce(){
  if (!ghostEnabled)  { tag('Ghost', 'avst√§ngd'); return; }
  if (playingGhost)   { tag('Ghost', 'spelar redan'); return; }
  if (!GHOST_CLIPS.length){ tag('Ghost','inga klipp'); return; }

  const src = pickGhost();
  tag('Ghost', 'startar', src);
  ghostEl.src = src;
  ghostEl.loop = false;
  ghostEl.currentTime = 0;

  try {
    const can = ghostEl.canPlayType('video/mp4');
    tag('Ghost', 'canPlayType(mp4)=', can || '(blank)');
    await ghostEl.play();
    playingGhost = true;
    tag('Ghost', 'play() OK');
  } catch (err) {
    playingGhost = false;
    console.error('[Ghost] play() fel', err);
    return;
  }

  // ‚úÖ flytta tillbaka 'ended'-hanteraren INUTI funktionen
  const end = () => {
    tag('Ghost','ended');
    ghostEl.pause();
    ghostEl.currentTime = 0;
    playingGhost = false;
    lastGhostTs = performance.now();
    ghostEl.removeEventListener('ended', end);
  };
  ghostEl.addEventListener('ended', end);
}

function maybeTriggerGhost(now){
  if (!ghostEnabled || !segReady) return;
  if (playingGhost) return;
  if ((now - lastGhostTs) < minGapMs) return;
  if (ghostFacesOnly && (window.__lastFaceCount||0) === 0) return;
  const avg = ghostAvgSec, pPerSec = 1 / Math.max(avg, 10), dtSec = 1/60;
  if (Math.random() < pPerSec * dtSec) playGhostOnce();
}

/* Rita kompositen */
function compositeFrame(){
  if (!composite || !compCtx || !video) return;
  if (video.readyState < 2) return;

  if (composite.width !== video.videoWidth || composite.height !== video.videoHeight){
    syncOverlaySize();
    tag('Draw','resize', composite.width, composite.height);
  }

  compCtx.clearRect(0,0,composite.width,composite.height);

  const hasGhost = (!ghostEl.paused && !ghostEl.ended);
  const hasMask  = !!latestMask;

  if (hasMask) {
    // 1) Sp√∂ket som bakgrund (bakom allt)
    if (hasGhost) {
      every(2, ()=> tag('Draw','ghost ritas (mask) @', ghostEl.currentTime?.toFixed?.(2)));
      compCtx.drawImage(ghostEl, 0, 0, composite.width, composite.height);
    } else {
      every(60, ()=> tag('Draw','ghost inaktiv (mask)'));
    }

    // 2) Live-bakgrund semi-opak (med filter)
    compCtx.globalAlpha = ghostBgAlpha;
    drawVideoWithFilter(compCtx, 0, 0, composite.width, composite.height);
    compCtx.globalAlpha = 1;

    // 3) Person i full opacitet via mask (med filter)
    try {
      const personCanvas = composite.__personCanvas || (composite.__personCanvas = document.createElement('canvas'));
      if (personCanvas.width !== composite.width || personCanvas.height !== composite.height){
        personCanvas.width = composite.width; personCanvas.height = composite.height;
      }
      const pctx = personCanvas.getContext('2d');
      pctx.clearRect(0,0,personCanvas.width,personCanvas.height);
      drawVideoWithFilter(pctx, 0, 0, personCanvas.width, personCanvas.height); // ‚Üê filter h√§r
      pctx.globalCompositeOperation = 'destination-in';
      pctx.drawImage(latestMask, 0, 0, personCanvas.width, personCanvas.height); // maska ut person
      pctx.globalCompositeOperation = 'source-over';
      compCtx.drawImage(personCanvas, 0, 0); // l√§gg personen √∂ver
    } catch (e) {
      console.warn('[MoodCam] Mask-render fel, faller tillbaka:', e);
      drawVideoWithFilter(compCtx, 0, 0, composite.width, composite.height);
    }

  } else {
    // üöë Fallback (ingen mask √§n):
    // 1) Rita live-video normalt (med filter)
    drawVideoWithFilter(compCtx, 0, 0, composite.width, composite.height);

    // 2) Rita sp√∂ket OVANP√Ö med l√•g opacitet s√• det syns √§nd√•
    if (hasGhost) {
      const ghostOverlayAlpha = Math.max(0.08, 1 - ghostBgAlpha); // t.ex. 0.12 om bgAlpha=0.88
      compCtx.globalAlpha = ghostOverlayAlpha;
      compCtx.drawImage(ghostEl, 0, 0, composite.width, composite.height);
      compCtx.globalAlpha = 1;
      every(2, ()=> tag('Draw','ghost ritas (fallback) @', ghostEl.currentTime?.toFixed?.(2),'Œ±=',ghostOverlayAlpha.toFixed(2)));
    } else {
      every(60, ()=> tag('Draw','ghost inaktiv (fallback)'));
    }
  }

  // Throttle segmentation (som tidigare)
  if (segReady && seg) {
    try {
      composite.__segToggle = (composite.__segToggle^1) || 1;
      if (!composite.__segToggle) seg.send({ image: video });
    } catch (e) {
      console.warn('[MoodCam] Segmentation fel ‚Äì st√§nger av mask:', e);
      segReady = false; seg = null; latestMask = null;
    }
  }
  // 4) Person fullt opak (s√§kerst√§ll filter √§ven h√§r)
  if (latestMask){
    const personCanvas = composite.__personCanvas || (composite.__personCanvas = document.createElement('canvas'));
    if (personCanvas.width !== composite.width || personCanvas.height !== composite.height){
      personCanvas.width = composite.width; personCanvas.height = composite.height;
    }
    const pctx = personCanvas.getContext('2d');
    pctx.clearRect(0,0,personCanvas.width,personCanvas.height);
    drawVideoWithFilter(pctx, 0, 0, personCanvas.width, personCanvas.height);
    pctx.globalCompositeOperation = 'destination-in';
    pctx.drawImage(latestMask, 0, 0, personCanvas.width, personCanvas.height);
    pctx.globalCompositeOperation = 'source-over';
    compCtx.drawImage(personCanvas, 0, 0);
  } else {
    drawVideoWithFilter(compCtx, 0, 0, composite.width, composite.height);
  }
}
function startGhostLoop(){
  function step(){
    const now = performance.now();
    maybeTriggerGhost(now);
    compositeFrame();
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

/* ---------- +1-animationer ---------- */
const plusOnes = [];
const PLUS_LIFE = 1.0; // ‚¨áÔ∏è n√•got kortare livstid (l√§gre kostnad)

function spawnPlusOne(x, y){
  // slumpm√§ssig riktning och fart
  const ang = Math.random()*Math.PI*2;
  const speed = 40 + Math.random()*100; // px/s
  plusOnes.push({
    x, y,
    vx: Math.cos(ang)*speed,
    vy: Math.sin(ang)*speed,
    age: 0
  });
}

function updateAndDrawPlusOnes(dt){
  for (let i=plusOnes.length-1;i>=0;i--){
    const p = plusOnes[i];
    p.age += dt;
    if (p.age >= PLUS_LIFE){ plusOnes.splice(i,1); continue; }
    // r√∂relse
    p.x += p.vx * dt;
    p.y += p.vy * dt;

    // easing f√∂r storlek & alpha
    const t = Math.max(0, Math.min(1, p.age/PLUS_LIFE));
    const grow = (t<0.25) ? (t/0.25) : 1;
    const fade = (t<0.7) ? (t/0.7) : (1 - (t-0.7)/0.3);
    const scale = 0.2 + 0.8*grow;

    ctx.save();
    ctx.globalAlpha = Math.max(0, Math.min(1, fade));
    
    // ‚¨áÔ∏è mindre och utan skuggor/konturer f√∂r l√§gre GPU-kostnad
    const size = Math.round(28 * scale);
    ctx.font = `bold ${size}px system-ui, "Apple Color Emoji", "Segoe UI Emoji", sans-serif`;
    ctx.textBaseline = 'middle';

    // M√§t bredder
    const txt1 = '+1';
    const txt2 = '‚ù§Ô∏è';
    const w1 = ctx.measureText(txt1).width;
    const w2 = ctx.measureText(txt2).width;
    const gap = Math.round(size * 0.25);
    const total = w1 + gap + w2;
    
    // Centrera hela paketet kring p.x
    const startX = p.x - total / 2;
    const y = p.y;
    
    // Rita +1 och hj√§rta (endast fill)
    ctx.textAlign = 'left';
    ctx.fillStyle = '#ffffff';
    ctx.fillText(txt1, startX, y);
    const heartX = startX + w1 + gap;
    ctx.fillText(txt2, heartX, y);
    
    ctx.restore();
  }
}

/* ---------- Huvudloop (detektering/overlay) ---------- */
let detectionFrameCounter = 0; // NY VARIABEL globalt
const DETECTION_EVERY_N_FRAMES = 5; // 60/5 = 12 detektioner/sekund

async function tick(){
  try{
    scheduleResetIfNeeded();
    FRAME_I++;

    const now = performance.now();
    const dt = Math.min(0.1, (now - lastFrameTime)/1000); lastFrameTime = now;

    if (FRAME_OPTS.ADAPTIVE_INPUT && (window.__lastFaceCount||0) >= FRAME_OPTS.MANY_FACES_THRESHOLD && DETECTOR_SIZE > FRAME_OPTS.LOW_INPUT_SIZE) {
      DETECTOR_SIZE = FRAME_OPTS.LOW_INPUT_SIZE;
      const isel = document.getElementById('inputSize'); if (isel) isel.value = DETECTOR_SIZE;
    }

    // üÜï DETEKTION BARA VAR 5:E FRAME
    detectionFrameCounter++;
    let frameHappyAdd = 0;
    let dets = [];
    if (detectionFrameCounter >= DETECTION_EVERY_N_FRAMES) {
      detectionFrameCounter = 0;

      const options = new faceapi.TinyFaceDetectorOptions({ inputSize: DETECTOR_SIZE, scoreThreshold: DETECTOR_SCORE });
      let builder = faceapi.detectAllFaces(video, options);
      if (LANDMARKS_AVAILABLE && typeof builder.withFaceLandmarks === 'function') builder = builder.withFaceLandmarks();
      builder = builder.withFaceExpressions().withAgeAndGender();

      const detsFull = await builder;

      dets = detsFull
        .slice()
        .sort((a,b)=> (b.detection.box.width*b.detection.box.height) - (a.detection.box.width*a.detection.box.height))
        .slice(0, 4);
      window.__lastFaceCount = dets.length;

      for (const det of dets){
        const b = det.detection.box; const bbox=[b.x,b.y,b.width,b.height];

        // matchning
        let best=null, bestIoU=0;
        for(const t of tracks){ const i=iou(t.bbox,bbox); if(i>bestIoU){bestIoU=i; best=t;} }
        if(best && bestIoU>0.3){
          const pb=best.bbox;
          best.bbox = pb
            ? [ema(pb[0], bbox[0], BBOX_POS_ALPHA),
               ema(pb[1], bbox[1], BBOX_POS_ALPHA),
               ema(pb[2], bbox[2], BBOX_SIZE_ALPHA),
               ema(pb[3], bbox[3], BBOX_SIZE_ALPHA)]
            : bbox.slice();
          best.last=now;
        } else {
          const t={ id:nextId++, bbox:bbox.slice(), last:now, created:now, seenFrames:0, counted:false,
                    peppText:null, ageHist:[], warm:0, contributing:false, effects:null, pose:{},
                    usePose:false, poseValid:0, poseInvalid:0, emo:'neutral', emoConf:0, lastAge:null,
                    contribAcc:0 // üîπ ack f√∂r +1 var hel sekund
                  };
          tracks.push(t); if(overlaysEnabled) assignEffects(t);
          best = t;
        }
        const tr=best;

        // Pose
        if (det.landmarks){
          const lm = det.landmarks;
          const mean = pts => { const n=pts.length; const s=pts.reduce((a,p)=>({x:a.x+p.x,y:a.y+p.y}),{x:0,y:0}); return {x:s.x/n,y:s.y/n}; };
          const dist = (a,b)=> Math.hypot(a.x-b.x,a.y-b.y);
          const mid  = (a,b)=> ({x:(a.x+b.x)/2, y:(a.y+b.y)/2});
          const Leye = mean(lm.getLeftEye());
          const Reye = mean(lm.getRightEye());
          const eyeC = mid(Leye, Reye);
          const eyeD = dist(Leye, Reye);
          const angle= Math.atan2(Reye.y - Leye.y, Reye.x - Leye.x);
          const mouth = lm.getMouth?.();
          const mL = mouth ? mouth[0] : null;
          const mR = mouth ? mouth[6] : null;
          const mouthC = (mL && mR) ? mid(mL, mR) : null;
          const mouthW = (mL && mR) ? dist(mL, mR) : null;
          const jaw = lm.getJawOutline?.();
          const faceW = jaw ? dist(jaw[0], jaw[16]) : null;
          const pz = tr.pose;
          pz.eyeCx   = ema(pz.eyeCx,   eyeC.x, POSE_ALPHA);
          pz.eyeCy   = ema(pz.eyeCy,   eyeC.y, POSE_ALPHA);
          pz.eyeD    = ema(pz.eyeD,    eyeD,   POSE_ALPHA);
          pz.angle   = ema(pz.angle,   angle,  POSE_ALPHA);
          if (mouthC){ pz.mouthCx = ema(pz.mouthCx, mouthC.x, POSE_ALPHA); pz.mouthCy = ema(pz.mouthCy, mouthC.y, POSE_ALPHA); }
          if (mouthW!=null) pz.mouthW = ema(pz.mouthW, mouthW, POSE_ALPHA);
          if (faceW!=null)  pz.faceW  = ema(pz.faceW,  faceW,  POSE_ALPHA);

          const validNow = isValidPose(tr.pose, {x:b.x, y:b.y, width:b.width, height:b.height});
          if (validNow) { tr.poseValid++; tr.poseInvalid=0; if(!tr.usePose && tr.poseValid>=2) tr.usePose=true; }
          else          { tr.poseInvalid++; tr.poseValid=0; if(tr.usePose && tr.poseInvalid>=6) tr.usePose=false; }
        }

        // Emotion & √•lder
        if (det.expressions){
          const exp=det.expressions||{}; let emo=null, conf=0; for(const [k,v] of Object.entries(exp)) if(v>conf){ emo=k; conf=v; }
          tr.emo = emo; tr.emoConf = conf;
        }
        const latestAge = ('age' in det) ? (det.age ?? null) : null;
        if (latestAge != null) tr.lastAge = latestAge;
        const shownAge = getSmoothedAge(tr, now, latestAge);

        // Glad-bidrag
        if (tr.emo === 'happy' && (tr.emoConf ?? 0) >= EMO_CONF_MIN) {
          const prevWarm = tr.warm || 0;
          tr.warm = Math.min(HAPPY_WARMUP_SECONDS, prevWarm + dt);

          // ‚¨ÖÔ∏è Starta +1 direkt n√§r warmup passerar tr√∂skeln
          if (prevWarm < HAPPY_WARMUP_SECONDS && tr.warm >= HAPPY_WARMUP_SECONDS) {
            const [bx,by,bw,bh]=tr.bbox;
            const rx = mirrorX(bx, bw);
            spawnPlusOne(rx + bw*0.5, by - 6);
          }

          if (tr.warm >= HAPPY_WARMUP_SECONDS) {
            if (!tr.counted) {
              const key=todayKey();
              visitorsByDay[key]=(visitorsByDay[key]||0)+1;
              localStorage.setItem('moodcam.visitors', JSON.stringify(visitorsByDay));
              updateLogInfo();
              tr.counted = true;
            }
            tr.contributing = true;
            const weight = CONTRIB_WEIGHT_BY_CONF ? tr.emoConf : 1;
            frameHappyAdd += dt * weight;

            // +1 en g√•ng per HEL sekund under p√•g√•ende bidrag
            tr.contribAcc += dt * weight;
            while (tr.contribAcc >= 1){
              const [bx,by,bw,bh]=tr.bbox;
              const rx = mirrorX(bx, bw);
              spawnPlusOne(rx + bw*0.5, by - 6);
              tr.contribAcc -= 1;
            }
          }
        } else {
          tr.warm = Math.max(0, (tr.warm || 0) - dt * 0.5);
          tr.contributing = false;
          tr.contribAcc = 0; // nollst√§ll ack n√§r man inte l√§ngre bidrar
        }
      }
    }

    // üÜï RITA ALLTID ‚Äì anv√§nd senaste tracks-data
    ctx.clearRect(0,0,overlay.width,overlay.height);
    for (const tr of tracks) {
      if (tr.last < now - 1500) continue; // gammal track

      const [bx,by,bw,bh] = tr.bbox; // REANV√ÑND SENASTE
      const rx = mirrorX(bx, bw);
      const color=EMO_COLOR[tr.emo]||'#24ff78';

      drawEffects(tr, bx,by,bw,bh);               // effekter anv√§nder pose + MIRROR internt

      if (SHOW_FACE_BOX) { ctx.strokeStyle=color; ctx.lineWidth=UI.faceBoxWidth; ctx.strokeRect(rx,by,bw,bh); }
      if(tr.emo && (tr.emoConf ?? 0) >= EMO_CONF_MIN){
        const shownAge = getSmoothedAge(tr, now, tr.lastAge);
        const label=`${EMO_SV[tr.emo]||tr.emo} ¬∑ ${Math.round(tr.emoConf*100)}%` + (shownAge!=null?` ¬∑ ${shownAge} √•r`:``);
        drawLabel(rx,by,label);
      } else if(shownAge!=null){ drawLabel(rx,by,`${shownAge} √•r`); }

      const emoji=EMO_EMOJI[tr.emo]||"üôÇ"; const emSize=Math.max(28, Math.round(Math.min(bw,bh)*0.22));
      ctx.font=`${emSize}px serif`; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(emoji, rx + bw, by);

      if (peppEnabled){
        if(!tr.peppText) tr.peppText = randomPepp();
        drawCenteredBottom(rx,by,bw,bh,tr.peppText);
      }
    }

    // gladtid + m√§tare (global)
    HAPPY_PERSON_SECONDS += frameHappyAdd;
    const targetPct = Math.min(100, 100*(HAPPY_PERSON_SECONDS/METER_GOAL_SECONDS));
    meterShown = meterShown + (targetPct - meterShown) * METER_EASE;
    document.getElementById('meterFill').style.width = Math.max(0,Math.min(100,meterShown)) + '%';
    document.getElementById('meterVal').textContent = Math.round(meterShown);

    // üîπ Rita +1-puffar √∂verst (efter allt annat)
    updateAndDrawPlusOnes(dt);

    // st√§da sp√•r
    const tnow=performance.now(); for(let i=tracks.length-1;i>=0;i--) if(tnow-tracks[i].last>1500) tracks.splice(i,1);

  } catch(err){
    console.error('[MoodCam] tick() error:', err);
  }
  requestAnimationFrame(tick);
}

/* ---------- Logg / CSV ---------- */
function updateLogInfo(){ const list=Object.entries(visitorsByDay).sort(([a],[b])=>a.localeCompare(b)); const txt=list.length? list.map(([d,n])=>`${d}: ${n}`).join(' ¬∑ ') : 'Ingen logg √§n.'; const el=document.getElementById('logInfo'); if(el) el.textContent=txt; }
function downloadCSV(){ const rows=[['date','visitors'],...Object.entries(visitorsByDay)]; const csv=rows.map(r=>r.join(',')).join('\n'); const blob=new Blob([csv],{type:'text/csv'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='moodcam_visitors.csv'; a.click(); URL.revokeObjectURL(a.href); }

/* ---------- Init ---------- */
async function init(){
  console.info('[MoodCam] Init‚Ä¶ TFJS:', (tf && tf.version_core)||'n/a', 'face-api:', (faceapi && faceapi.version)||'n/a');

  // Backend
  try { await tf.setBackend('webgl'); await tf.ready(); console.info('[MoodCam] TF backend:', tf.getBackend()); }
  catch(e) {
    console.warn('[MoodCam] WebGL misslyckades, provar WASM:', e);
    try { await tf.setBackend('wasm'); await tf.ready(); console.info('[MoodCam] TF backend:', tf.getBackend()); }
    catch(e2){ console.warn('[MoodCam] WASM misslyckades ocks√•:', e2); }
  }

  const wrap=document.getElementById('wrap');
  video=document.getElementById('video');
  overlay=document.getElementById('overlay'); ctx=overlay.getContext('2d');
  composite=document.getElementById('composite'); compCtx=composite.getContext('2d', { willReadFrequently:true });
  ghostEl=document.getElementById('ghost');

  // Spegel: appliceras som CSS-klass p√• COMPOSITE
  const mirrorBox = document.getElementById('mirrorX');
  MIRROR = !!mirrorBox.checked;
  wrap.classList.toggle('mirror', MIRROR);

  // UI handlers
  document.getElementById('settingsBtn').addEventListener('click', ()=>{ const s=document.getElementById('settings'); s.style.display=(s.style.display==='none'||!s.style.display)?'block':'none'; });
  document.getElementById('conf').addEventListener('input', e=> EMO_CONF_MIN=parseFloat(e.target.value));
  document.getElementById('inputSize').addEventListener('input', e=> DETECTOR_SIZE=parseInt(e.target.value,10));
  document.getElementById('score').addEventListener('input', e=> DETECTOR_SCORE=parseFloat(e.target.value));
  document.getElementById('peppToggle').addEventListener('change', e=> { peppEnabled=e.target.checked; });
  document.getElementById('peppCat').addEventListener('change', e=> { peppCat=e.target.value; });

  ['fBrightness','fContrast','fSaturate','fHue','fTemp'].forEach(id=>{
    document.getElementById(id).addEventListener('input', ()=>{
      CAM_FILTER = buildCamFilterString();     // ‚Üê uppdatera canvas-filtret
      video.style.filter = CAM_FILTER;         // (valfritt, om videon skulle visas)
    });
  });
  document.getElementById('filtersReset').addEventListener('click', ()=>{
    fBrightness.value=100; fContrast.value=100; fSaturate.value=100; fHue.value=0; fTemp.value=0;
    CAM_FILTER = buildCamFilterString();
    video.style.filter = CAM_FILTER;
    const evt=new Event('input'); fBrightness.dispatchEvent(evt);
  });
  // initiera filter en g√•ng
  CAM_FILTER = buildCamFilterString();
  video.style.filter = CAM_FILTER;

  document.getElementById('mirrorX').addEventListener('change', e=>{
    MIRROR = e.target.checked; wrap.classList.toggle('mirror', MIRROR);
  });

  const showBoxEl = document.getElementById('showBox');
  showBoxEl.checked = SHOW_FACE_BOX;
  showBoxEl.addEventListener('change', e=>{ SHOW_FACE_BOX = e.target.checked; });

  const themeSel = document.getElementById('themeSel');
  THEMES.forEach(t=>{ const o=document.createElement('option'); o.value=t; o.textContent=t; themeSel.appendChild(o); });
  themeSel.value = selectedTheme;
  themeSel.addEventListener('change', async e=>{
    selectedTheme = e.target.value;
    if (overlaysEnabled) { await loadOverlayManifest(selectedTheme); tracks.forEach(t=>assignEffects(t)); }
  });

  // ‚úÖ Synka startl√§ge fr√•n checkboxar: overlays av, endast glas√∂gon p√•
  const overlayToggleEl = document.getElementById('overlayToggle');
  const ovHatsEl = document.getElementById('ovHats');
  const ovGlassesEl = document.getElementById('ovGlasses');
  const ovEyesEl = document.getElementById('ovEyes');
  const ovMouthEl = document.getElementById('ovMouth');
  const ovBeardEl = document.getElementById('ovBeard');

  overlaysEnabled = overlayToggleEl.checked; // false
  overlayUse.hats   = ovHatsEl.checked;      // false
  overlayUse.glasses= ovGlassesEl.checked;   // true
  overlayUse.eyes   = ovEyesEl.checked;      // false
  overlayUse.mouth  = ovMouthEl.checked;     // false
  overlayUse.beard  = ovBeardEl.checked;     // false

  overlayToggleEl.addEventListener('change', async e=> {
    overlaysEnabled=e.target.checked;
    if (overlaysEnabled && !overlayManifest) await loadOverlayManifest(selectedTheme);
    tracks.forEach(t=>assignEffects(t));
  });
  ovHatsEl.addEventListener('change', e=> { overlayUse.hats=e.target.checked; tracks.forEach(t=>assignEffects(t)); });
  ovGlassesEl.addEventListener('change', e=> { overlayUse.glasses=e.target.checked; tracks.forEach(t=>assignEffects(t)); });
  ovEyesEl.addEventListener('change', e=> { overlayUse.eyes=e.target.checked; tracks.forEach(t=>assignEffects(t)); });
  ovMouthEl.addEventListener('change', e=> { overlayUse.mouth=e.target.checked; tracks.forEach(t=>assignEffects(t)); });
  ovBeardEl.addEventListener('change', e=> { overlayUse.beard=e.target.checked; tracks.forEach(t=>assignEffects(t)); });

  document.getElementById('dlLog').addEventListener('click', downloadCSV);
  document.getElementById('clearLog').addEventListener('click', ()=> { localStorage.setItem('moodcam.visitors','{}'); for (const k in visitorsByDay) delete visitorsByDay[k]; updateLogInfo(); });

  const goalInput=document.getElementById('goalSec'); const goalLabel=document.getElementById('goalLabel');
  METER_GOAL_SECONDS=parseInt(goalInput.value,10); goalLabel.textContent=METER_GOAL_SECONDS;
  goalInput.addEventListener('input', e=>{ METER_GOAL_SECONDS=parseInt(e.target.value,10); goalLabel.textContent=METER_GOAL_SECONDS; });

  // Sp√∂k-settings
  const ghostToggle = document.getElementById('ghostToggle');
  const ghostModeSel = document.getElementById('ghostMode');
  const ghostFacesOnlyEl = document.getElementById('ghostFacesOnly');
  const ghostBgAlphaEl = document.getElementById('ghostBgAlpha');

  ghostEl.addEventListener('loadeddata', ()=> tag('Ghost','loadeddata', ghostEl.videoWidth, ghostEl.videoHeight));
  ghostEl.addEventListener('play', ()=> tag('Ghost','play'));
  ghostEl.addEventListener('pause', ()=> tag('Ghost','pause'));
  ghostEl.addEventListener('error', ()=> console.error('[Ghost] video error', ghostEl.error));
  document.getElementById('ghostNow').addEventListener('click', ()=> { tag('Ghost','knapp: spela nu'); playGhostOnce(); });

  // ‚õîÔ∏è Startl√§ge: av
  ghostEnabled = ghostToggle.checked;       // false
  ghostMode = ghostModeSel.value; ghostAvgSec = modeToAvgSec(ghostMode);
  ghostFacesOnly = ghostFacesOnlyEl.checked;
  ghostBgAlpha = parseInt(ghostBgAlphaEl.value,10)/100;

  ghostToggle.addEventListener('change', e=>{ ghostEnabled = e.target.checked; tag('Ghost','enabled=', ghostEnabled); });
  ghostModeSel.addEventListener('change', e=>{ ghostMode = e.target.value; ghostAvgSec = modeToAvgSec(ghostMode); tag('Ghost','mode=',ghostMode,'avgSec=',ghostAvgSec); });
  ghostFacesOnlyEl.addEventListener('change', e=>{ ghostFacesOnly = e.target.checked; tag('Ghost','facesOnly=',ghostFacesOnly); });
  ghostBgAlphaEl.addEventListener('input', e=>{ ghostBgAlpha = parseInt(e.target.value,10)/100; tag('Ghost','bgAlpha=',ghostBgAlpha); });

  await loadAssetMeta();
  await loadPepp();
  listCams(1);
  ensureModelsLoading();
  await setupSegmentation();

  document.getElementById('start').addEventListener('click', async ()=>{
    const modelsOK = await ensureModelsLoading(); if (!modelsOK) return;
    const sel=document.getElementById('camSel');
    const ok = await startCamera(sel.value); if (!ok) return;

    new ResizeObserver(()=>{ syncOverlaySize(); }).observe(document.getElementById('wrap'));

    console.info('[MoodCam] Kamera ig√•ng, startar loop‚Ä¶');
    requestAnimationFrame(tick);
    startGhostLoop();
    tag('Init','kamera ig√•ng, loopar. video=', video.videoWidth, video.videoHeight);
    document.getElementById('start').disabled = true;
  });

  window.addEventListener('error', (e)=> console.error('[MoodCam] window error:', e.error||e.message));
}
window.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
