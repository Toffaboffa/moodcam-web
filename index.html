<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Vialundskolans MoodCam (v.1.2.1)</title>
  <!-- Slipp favicon 404 -->
  <link rel="icon" href="data:,">
  <style>
    :root{--bg:#0b0f14;--fg:#e7effa;--panel:#0f172a;--panel2:#111827;--border:#1f2937;--accent:#22c55e}
    html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,sans-serif}
    #stage{display:grid;grid-template-columns:1fr;gap:16px;height:100vh;align-items:center;justify-items:center;padding:12px}
    .topbar{position:fixed;top:10px;left:10px;display:flex;gap:8px;z-index:10}
    .btn{background:var(--panel2);border:1px solid var(--border);color:var(--fg);padding:8px 12px;border-radius:8px;cursor:pointer}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .layer-wrap{position:relative;display:inline-block;border-radius:12px;overflow:hidden;box-shadow:0 12px 36px rgba(0,0,0,.5);max-width:96vw;max-height:86vh}
    video{display:block;width:100%;height:auto}
    canvas{position:absolute;inset:0;width:100%;height:100%;pointer-events:none}
    #meterWrap{position:absolute;left:50%;transform:translateX(-50%);bottom:0;background:var(--panel);border:1px solid var(--border);border-bottom-left-radius:0;border-bottom-right-radius:0;border-top-left-radius:10px;border-top-right-radius:10px;padding:6px 10px;width:min(360px,70%);z-index:5}
    #meterBar{position:relative;height:8px;background:#0d1218;border-radius:6px;overflow:hidden;border:1px solid var(--border)}
    #meterFill{height:100%;width:0%;background:linear-gradient(90deg,#2dd4bf,#22c55e)}
    .meterVal{position:absolute;right:6px;top:-16px;opacity:.85}
    .small{font-size:12px;opacity:.8}
    #settings{display:none;position:fixed;right:12px;top:52px;width:360px;max-height:85vh;overflow:auto;background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:12px 12px 8px;z-index:20}
    #settings h3{margin:6px 0 8px 0;font-size:16px}
    #settings .row{display:flex;justify-content:space-between;align-items:center;margin:8px 0}
    #settings label{font-size:14px}
    details{border:1px dashed var(--border);border-radius:8px;padding:6px;margin-top:8px}
    summary{cursor:pointer}
    .desc{font-size:12px;opacity:.75;margin:4px 0 0}
    input[type="range"]{width:190px}
    .two-col{display:grid;grid-template-columns:auto 1fr;gap:8px;align-items:center}
    .hud{position:fixed;left:14px;bottom:14px;font-size:12px;opacity:.7}
  </style>

  <!-- Cache-bust med ?v=mc1 s√• vi s√§kert laddar ny kod -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.21.0/dist/tf.min.js?v=mc1"></script>
  <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api/dist/face-api.min.js?v=mc1"></script>
</head>
<body>
  <div class="topbar">
    <button id="start" class="btn">Starta kamera</button>
    <button id="settingsBtn" class="btn">Settings</button>
  </div>

  <div id="stage">
    <div class="layer-wrap" id="wrap">
      <video id="video" autoplay muted playsinline></video>
      <canvas id="overlay"></canvas>

      <div id="meterWrap">
        <div id="meterBar">
          <div id="meterFill"></div>
          <span id="meterVal" class="small meterVal">0</span>
        </div>
        <div class="small" style="margin-top:2px">
          Moodm√§tare ‚Äì B√∂rjar √∂ka efter <em>3s</em>, s√• SMILE üòÑ
        </div>
      </div>
    </div>
  </div>

  <div id="settings">
    <h3>Settings</h3>
    <div class="row">
      <label for="camSel">Kamera</label>
      <select id="camSel" class="btn" style="width:220px"></select>
    </div>
    <div class="row">
      <label for="conf">Konfidens (etikett)</label>
      <input id="conf" type="range" min="0.2" max="0.9" step="0.05" value="0.40">
    </div>
    <div class="row">
      <label for="inputSize">Detector size</label>
      <input id="inputSize" type="range" min="224" max="512" step="32" value="320">
    </div>

    <details open>
      <summary>Peppande one-liners</summary>
      <div class="row" style="margin-top:8px">
        <label>Aktivera</label><input type="checkbox" id="peppToggle" checked>
      </div>
      <div class="row">
        <label for="peppCat">Kategori</label>
        <select id="peppCat" class="btn" style="width:220px">
          <option value="all">Alla</option>
          <option value="skola">Skola</option>
          <option value="maende">M√•ende</option>
          <option value="basta">G√∂r ditt b√§sta</option>
          <option value="van">V√§nskap</option>
        </select>
      </div>
      <p class="desc">Visas i varje ansiktsruta, l√•ses per person tills de l√§mnar bild.</p>
    </details>

    <details>
      <summary>Overlays & teman</summary>
      <div class="row">
        <label>Aktivera overlays</label><input type="checkbox" id="overlayToggle">
      </div>
      <div class="row">
        <label for="themeSel">Tema</label>
        <select id="themeSel" class="btn" style="width:220px"></select>
      </div>
      <div class="row"><label>Hattar</label><input type="checkbox" id="ovHats" checked></div>
      <div class="row"><label>Glas√∂gon</label><input type="checkbox" id="ovGlasses" checked></div>
      <div class="row"><label>√ñgon</label><input type="checkbox" id="ovEyes" checked></div>
      <div class="row"><label>Munnar</label><input type="checkbox" id="ovMouth" checked></div>
      <div class="row"><label>Sk√§gg</label><input type="checkbox" id="ovBeard" checked></div>
      <p class="desc">Tema anger *vilka filer*; passform kommer fr√•n <code>img/assets/meta.json</code>.</p>
    </details>

    <details>
      <summary>Kamera ‚Äì bild (filter)</summary>
      <div class="two-col">
        <label for="fBrightness">Ljusstyrka</label><input id="fBrightness" type="range" min="50" max="150" step="1" value="100">
        <label for="fContrast">Kontrast</label><input id="fContrast"   type="range" min="50" max="150" step="1" value="100">
        <label for="fSaturate">M√§ttnad</label><input id="fSaturate"    type="range" min="0"  max="200" step="1" value="100">
        <label for="fHue">Ton (¬∞)</label><input id="fHue"              type="range" min="-180" max="180" step="1" value="0">
        <label for="fTemp">Temperatur</label><input id="fTemp"         type="range" min="-50" max="50" step="1" value="0">
      </div>
      <div class="row"><button id="filtersReset" class="btn">√Öterst√§ll</button></div>
      <p class="desc">P√•verkar bara visningen (inte detekteringen).</p>
    </details>

    <details>
      <summary>Bes√∂kslogg</summary>
      <div class="row" style="margin-top:8px">
        <button id="dlLog" class="btn">Ladda ner CSV</button>
        <button id="clearLog" class="btn" style="background:#581c1c;border-color:#7f1d1d">Nollst√§ll</button>
      </div>
      <p id="logInfo" class="small"></p>
    </details>

    <details>
      <summary>Moodm√§tare ‚Äì m√•l</summary>
      <div class="row">
        <label for="goalSec">M√•l (sekunder glad-tid)</label>
        <input id="goalSec" type="range" min="300" max="3600" step="60" value="900">
      </div>
      <p class="small">Nuvarande m√•l: <span id="goalLabel">900</span> s</p>
    </details>
  </div>

  <div class="hud">Allt k√∂rs lokalt i datorn. /Kristoffer</div>

<script>
/* ---------- Konsolfilter (tysta biblioteksspam) ---------- */
const ORIG_CONSOLE = { info: console.info, warn: console.warn, log: console.log };
const NOISE_PATTERNS = [
  /already been set/i,
  /backend was already registered/i,
  /kernel .* already registered/i
];
console.warn = (...args)=>{ const s=(args||[]).join(' '); if (NOISE_PATTERNS.some(r=>r.test(s))) return; ORIG_CONSOLE.warn.apply(console,args); };
console.info = (...args)=>{ const s=(args||[]).join(' '); if (NOISE_PATTERNS.some(r=>r.test(s))) return; ORIG_CONSOLE.info.apply(console,args); };
// L√§mna console.error or√∂rd.

const DEBUG = false;

/* ---------- Konstanter & state ---------- */
const EMO_SV = { angry:"Arg", disgusted:"√Ñcklad", fearful:"R√§dd", happy:"Glad", neutral:"Neutral", sad:"Ledsen", surprised:"F√∂rv√•nad" };
const EMO_EMOJI = { angry:"üò†", disgusted:"ü§¢", fearful:"üò®", happy:"üòÑ", neutral:"üòê", sad:"üò¢", surprised:"üòÆ" };
const EMO_COLOR = { happy:"#28c728", angry:"#2a2ae0", sad:"#c07800", surprised:"#c0c000", fearful:"#00b4b4", disgusted:"#00a078", neutral:"#b0b0b0" };
const UI = { labelFontSize:14, labelPad:3, pepFontSize:14, pepPad:3, faceBoxWidth:2 };

let EMO_CONF_MIN = 0.40;
let DETECTOR_SIZE = 320;

let peppEnabled = true;
let peppCat = 'all';
const THEMES = ["Aktivt (img/manifest.json)","halloween","jul","sommar","skolstart","test"];
let selectedTheme = THEMES[0];

let overlaysEnabled = false;
const overlayUse = { hats:true, glasses:true, eyes:true, mouth:true, beard:true };
let overlayManifest = null;
const imgCache = new Map();

let assetMeta = {};
async function loadAssetMeta(){
  try{
    const r = await fetch('./img/assets/meta.json', {cache:'no-store'});
    if (r.ok) assetMeta = await r.json();
  }catch(e){ if (DEBUG) console.warn('[MoodCam] assets/meta.json saknas/ol√§slig', e); }
}

let LANDMARKS_AVAILABLE = false;

let video, overlay, ctx, currentStream=null;

/* Tracks */
const tracks = [];
let nextId = 1;

let lastFrameTime = performance.now();

/* Mood-meter */
let HAPPY_PERSON_SECONDS = 0;
let METER_GOAL_SECONDS = 900;
let meterShown = 0;
const METER_EASE = 0.07;
const HAPPY_WARMUP_SECONDS = 3;
const CONTRIB_WEIGHT_BY_CONF = true;

const RESET_H = 19, RESET_M = 30;

/* Jitter-filter */
const POSE_ALPHA = 0.15;
const BBOX_ALPHA = 0.25;
const ema = (prev, next, a)=> (prev==null? next : prev + a*(next - prev));

/* Logg */
const visitorsByDay = JSON.parse(localStorage.getItem('moodcam.visitors') || '{}');
updateLogInfo();
const AGE_SMOOTH_WINDOW_MS = 10_000;

/* ---------- Hj√§lp ---------- */
function todayKey(){ const d=new Date(); return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`; }
function scheduleResetIfNeeded(){ const now=new Date(); const reset=new Date(); reset.setHours(RESET_H, RESET_M, 0, 0); if (Math.abs(now-reset)<1000){ HAPPY_PERSON_SECONDS=0; meterShown=0; } }
function iou(a,b){ const [ax,ay,aw,ah]=a,[bx,by,bw,bh]=b; const x1=Math.max(ax,bx), y1=Math.max(ay,by), x2=Math.min(ax+aw,bx+bw), y2=Math.min(ay+ah,by+bh);
  const inter=Math.max(0,x2-x1)*Math.max(0,y2-y1), union=aw*ah+bw*bh-inter; return union>0? inter/union:0; }

function drawLabel(x,y,text){
  ctx.font = `${UI.labelFontSize}px system-ui`; ctx.textAlign='left'; ctx.textBaseline='alphabetic';
  const pad=UI.labelPad, h=UI.labelFontSize*1.2, w=ctx.measureText(text).width;
  ctx.fillStyle='rgba(0,0,0,0.85)'; ctx.fillRect(x-pad,y-h-pad,w+pad*2,h+pad*2);
  ctx.fillStyle='#fff'; ctx.fillText(text,x,y);
}
function drawCenteredBottom(x,y,w,h,text){
  ctx.font = `${UI.pepFontSize}px system-ui`; ctx.textAlign='left'; ctx.textBaseline='alphabetic';
  const pad=UI.pepPad, htxt=UI.pepFontSize*1.2, tw=ctx.measureText(text).width, cx=x+w/2-tw/2, cy=y+h-8;
  ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(cx-pad,cy-htxt-pad,tw+pad*2,htxt+pad*2);
  ctx.fillStyle='#fff'; ctx.fillText(text,cx,cy);
}
function syncOverlaySize(){ overlay.width=video.videoWidth; overlay.height=video.videoHeight; overlay.style.width=video.clientWidth+'px'; overlay.style.height=video.clientHeight+'px'; }

function getSmoothedAge(track, now, latestAge){
  if (latestAge!=null && !Number.isNaN(latestAge)) track.ageHist.push({t:now,a:latestAge});
  const cutoff=now-AGE_SMOOTH_WINDOW_MS; while (track.ageHist.length && track.ageHist[0].t<cutoff) track.ageHist.shift();
  if (now-track.created<AGE_SMOOTH_WINDOW_MS) return latestAge!=null?Math.round(latestAge):null;
  if (!track.ageHist.length) return latestAge!=null?Math.round(latestAge):null;
  const avg=track.ageHist.reduce((s,p)=>s+p.a,0)/track.ageHist.length; return Math.round(avg);
}

/* --------- Overlays & teman --------- */
async function loadOverlayManifest(themeName){
  overlayManifest=null;
  let url;
  if (!themeName || themeName === THEMES[0]) url = './img/manifest.json';
  else url = `./img/tema/${themeName}/manifest.json`;
  try{
    const resp=await fetch(url,{cache:'no-store'});
    if(!resp.ok) return;
    const data=await resp.json();
    if (!data.facial_hair && data.faceal_hair) data.facial_hair = data.faceal_hair;
    for (const cat of ["hats","glasses","eyes","mouth","facial_hair"]) {
      const src = data[cat] || [];
      data[cat] = src.map(it => (typeof it === 'string' ? { file: it } : it));
    }
    overlayManifest = data;
    const toLoad=[];
    for (const cat of ["hats","glasses","eyes","mouth","facial_hair"]) {
      (data[cat]||[]).forEach(item=>{
        const path = `./img/${item.file}`;
        if(!imgCache.has(path)){
          const im=new Image(); im.src=path; imgCache.set(path, im);
          toLoad.push(im.decode?.() ?? new Promise(r=>{im.onload=r;im.onerror=r;}));
        }
      });
    }
    await Promise.all(toLoad);
  } catch(e){ if (DEBUG) console.warn('[MoodCam] Overlay manifest kunde inte laddas', e); }
}
function choiceWeighted(arr){
  if(!arr || !arr.length) return null;
  const weights = arr.map(o => (o.prob ?? 1));
  const sum = weights.reduce((a,b)=>a+b,0);
  let r = Math.random()*sum;
  for (let i=0;i<arr.length;i++){ r -= weights[i]; if (r <= 0) return arr[i]; }
  return arr[arr.length-1];
}
function assignEffects(track){
  if(!overlaysEnabled || !overlayManifest){ track.effects=null; return; }
  const e={};
  if (overlayUse.hats)    e.hat   = choiceWeighted(overlayManifest.hats) || null;
  if (overlayUse.glasses) e.glass = choiceWeighted(overlayManifest.glasses) || null;
  if (overlayUse.eyes)    e.eyes  = choiceWeighted(overlayManifest.eyes) || null;
  if (overlayUse.mouth)   e.mouth = choiceWeighted(overlayManifest.mouth) || null;
  if (overlayUse.beard)   e.beard = choiceWeighted(overlayManifest.facial_hair) || null;
  track.effects = e;
}

/* ---- Pose sanity ---- */
function isValidPose(p, w, h){
  if (!p) return false;
  const ok = v => Number.isFinite(v);
  if (!ok(p.eyeCx)||!ok(p.eyeCy)||!ok(p.eyeD)) return false;
  const minEyeD = Math.max(6, Math.min(w,h)*0.06);
  const maxEyeD = Math.min(w*0.9, Math.min(w,h)*0.8);
  if (!(p.eyeD > minEyeD && p.eyeD < maxEyeD)) return false;
  if (ok(p.mouthW) && !(p.mouthW > minEyeD*0.6 && p.mouthW < w*1.2)) return false;
  if (!(p.eyeCx >= -w*0.2 && p.eyeCx <= w*1.2 && p.eyeCy <= h*1.2)) return false;
  return true;
}
function defaultFitForFile(path){
  if (path.startsWith('assets/glasses/'))     return 'glasses';
  if (path.startsWith('assets/eyes/'))        return 'eyes';
  if (path.startsWith('assets/mouth/'))       return 'mouth';
  if (path.startsWith('assets/facial_hair/')) return 'beard';
  if (path.startsWith('assets/hats/'))        return 'hat';
  return 'bbox';
}

/* ---------- Pepp: enkla fraser ---------- */
const PEPP = {
  all: [
    "Du fixar det h√§r! üí™","Snyggt fokus!","En sak i taget.","Andas in, andas ut üòä",
    "Testa igen ‚Äì nu sitter den!","Bra energi!"
  ],
  skola: ["Kunskap = superkraft","Skriv lite till ‚úçÔ∏è","Du l√§r dig nu!"],
  maende: ["Ta en mikropaus üíß","Str√§ck p√• dig!","Ditt b√§sta r√§cker."],
  basta: ["G√∂r ditt b√§sta ‚Äì det r√§cker","Sm√• steg ‚ûú stora resultat"],
  van: ["Var sn√§ll ‚Äì det smittar ü§ù","Le mot n√•gon idag üôÇ"]
};
function randomPepp(){
  const pool = peppCat==='all' ? Object.values(PEPP).flat() : (PEPP[peppCat]||PEPP.all);
  return pool[Math.floor(Math.random()*pool.length)];
}

function drawItem(meta, track, x,y,w,h){
  if(!meta) return;
  const path = `./img/${meta.file}`;
  const img = imgCache.get(path); if(!img) return;

  const mAsset = assetMeta[meta.file] || {};
  const cfg = { ...meta, ...mAsset };
  const fit = (cfg.fit || defaultFitForFile(cfg.file));
  const flipX = !!cfg.flipX;
  const rotWithEyes = (cfg.rot !== false);

  const usePose = track.usePose && fit !== 'bbox';

  if (usePose){
    const p = track.pose;
    const eyeC = {x:p.eyeCx, y:p.eyeCy};
    const eyeD = p.eyeD;
    const angle= p.angle || 0;
    const mouthC = (p.mouthCx!=null && p.mouthCy!=null) ? {x:p.mouthCx, y:p.mouthCy} : {x:eyeC.x, y:eyeC.y + eyeD*0.6};
    const mouthW = p.mouthW || eyeD*0.9;
    const faceW  = p.faceW  || w;

    let cx, cy, refW, defWF=1.0, defY=0, defX=0;
    if (fit==='eyes' || fit==='glasses'){ cx=eyeC.x; cy=eyeC.y; refW=eyeD; defWF=(fit==='eyes')?2.2:2.0; defY=(fit==='eyes')?0.15:0.05; }
    else if (fit==='mouth'){ cx=mouthC.x; cy=mouthC.y; refW=mouthW; defWF=1.3; }
    else if (fit==='beard'){ cx=mouthC.x; cy=mouthC.y + eyeD*0.55; refW=faceW; defWF=0.9; defY=0.05; }
    else if (fit==='hat'){ cx=eyeC.x; cy=eyeC.y - eyeD*0.9; refW=faceW; defWF=1.1; defY=-0.15; }

    const wf = (cfg.wFactor ?? defWF);
    const drawW = refW * wf;
    const drawH = drawW * (img.naturalHeight/img.naturalWidth);

    const dx = (cfg.xOffset || defX) * refW;
    const dy = ((cfg.yOffset !== undefined ? cfg.yOffset : defY)) * refW;

    ctx.save();
    if (rotWithEyes){
      ctx.translate(eyeC.x + dx, eyeC.y + dy);
      if (flipX) ctx.scale(-1,1);
      ctx.rotate(angle);
      ctx.drawImage(img, -drawW/2, -drawH/2, drawW, drawH);
    } else {
      const px = eyeC.x + dx - drawW/2, py = eyeC.y + dy - drawH/2;
      if (flipX){ ctx.translate(px+drawW/2, py+drawH/2); ctx.scale(-1,1); ctx.drawImage(img,-drawW/2,-drawH/2,drawW,drawH); }
      else ctx.drawImage(img, px, py, drawW, drawH);
    }
    ctx.restore();
    return;
  }

  // Fallback: bbox
  const def = (()=> {
    if(cfg.file.startsWith('assets/hats/'))        return {dx:0.10, dy:-0.35, scale:0.80};
    if(cfg.file.startsWith('assets/glasses/'))     return {dx:0.20, dy:0.28, scale:0.60};
    if(cfg.file.startsWith('assets/eyes/'))        return {dx:0.18, dy:0.22, scale:0.64};
    if(cfg.file.startsWith('assets/mouth/'))       return {dx:0.35, dy:0.65, scale:0.30};
    if(cfg.file.startsWith('assets/facial_hair/')) return {dx:0.25, dy:0.62, scale:0.50};
    return {dx:0.2, dy:0.2, scale:0.6};
  })();

  const bw = w * (cfg.scale ?? def.scale);
  const bh = bw * (img.naturalHeight/img.naturalWidth);
  const eyeApprox = w * 0.35;
  const extraX = (cfg.xOffset != null ? cfg.xOffset * eyeApprox : 0);
  const extraY = (cfg.yOffset != null ? cfg.yOffset * eyeApprox : 0);
  const px = x + (cfg.dx ?? def.dx) * w + extraX;
  const py = y + (cfg.dy ?? def.dy) * h + extraY;

  ctx.save();
  if (flipX){ ctx.translate(px+bw/2, py+bh/2); ctx.scale(-1,1); ctx.drawImage(img,-bw/2,-bh/2,bw,bh); }
  else ctx.drawImage(img, px, py, bw, bh);
  ctx.restore();
}
function drawEffects(track,x,y,w,h){
  if(!overlaysEnabled || !track.effects) return;
  const e=track.effects;
  drawItem(e.hat,   track, x,y,w,h);
  drawItem(e.glass, track, x,y,w,h);
  drawItem(e.eyes,  track, x,y,w,h);
  drawItem(e.mouth, track, x,y,w,h);
  drawItem(e.beard, track, x,y,w,h);
}

/* ---------- Kamera ---------- */
async function listCams(defaultIndex=0){
  const sel = document.getElementById('camSel');
  sel.innerHTML = '';
  try{
    const devices = (await navigator.mediaDevices.enumerateDevices()).filter(d => d.kind === 'videoinput');
    devices.forEach((d,i)=>{
      const o=document.createElement('option'); o.value=d.deviceId||''; o.textContent=d.label||`Kamera ${i+1}`; sel.appendChild(o);
    });
    if (!sel.value && devices.length) sel.selectedIndex = Math.min(defaultIndex, devices.length-1);
  }catch(e){ if (DEBUG) console.warn('[MoodCam] enumerateDevices fel', e); }
}
async function startCamera(deviceId){
  try{
    if (currentStream) currentStream.getTracks().forEach(t => t.stop());
    const base = { width:{ideal:1280}, height:{ideal:720}, frameRate:{ideal:30}, facingMode:'user' };
    const constraints = { audio:false, video: deviceId ? { ...base, deviceId:{ exact: deviceId } } : base };
    currentStream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = currentStream;
    await new Promise(r=>{ const f=()=>{video.removeEventListener('loadedmetadata',f); r();}; if(video.readyState>=1) r(); else video.addEventListener('loadedmetadata',f); });
    await video.play().catch(()=>{});
    syncOverlaySize();
    return true;
  }catch(err){
    console.error('[MoodCam] getUserMedia failed', err);
    alert('Kunde inte starta kameran.\n' + (err.name?`${err.name}: `:'') + (err.message||'Ok√§nt fel.') + '\nTips: k√∂r √∂ver HTTPS/localhost och st√§ng andra appar som anv√§nder kameran.');
    return false;
  }
}

/* ---------- Modeller ---------- */
let modelsPromise=null;
function ensureModelsLoading(){
  if (modelsPromise) return modelsPromise;
  modelsPromise = (async ()=>{
    console.info('[MoodCam] Laddar modeller ‚Ä¶');
    console.time('[MoodCam] Modeller klara');
    try{
      const base='./models/';
      await faceapi.nets.tinyFaceDetector.load(base);
      await faceapi.nets.faceExpressionNet.load(base);
      await faceapi.nets.ageGenderNet.load(base);
      try{
        await faceapi.nets.faceLandmark68Net.load(base);
        LANDMARKS_AVAILABLE=true;
        console.info('[MoodCam] Landmarks aktiverade');
      }catch(e){
        LANDMARKS_AVAILABLE=false;
        if (DEBUG) console.warn('[MoodCam] Landmarks kunde inte laddas:', e);
      }
      console.timeEnd('[MoodCam] Modeller klara');
      return true;
    }catch(e){
      console.error('[MoodCam] Kunde inte l√§sa in modeller', e);
      alert('Kunde inte l√§sa in AI-modellerna fr√•n /models/. Kontrollera att mappen /models/ finns och att filerna √§r √•tkomliga.');
      return false;
    }
  })();
  return modelsPromise;
}

/* ---------- ‚Äù√Ñcklad‚Äù-heuristik ---------- */
function mouthAspectRatio(landmarks){
  if(!landmarks) return 0;
  const pts=landmarks.getMouth(), d=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
  const top=pts[13], bot=pts[19], left=pts[0], right=pts[6];
  return d(top,bot)/(d(left,right)+1e-6);
}

/* ---------- Huvudloop ---------- */
async function tick(){
  try{
    scheduleResetIfNeeded();

    const now = performance.now();
    const dt = Math.min(0.1, (now - lastFrameTime)/1000); lastFrameTime = now;

    const options = new faceapi.TinyFaceDetectorOptions({ inputSize: DETECTOR_SIZE, scoreThreshold: 0.6 });

    let builder = faceapi.detectAllFaces(video, options);
    const typeBefore = typeof builder.withFaceLandmarks;
    if (LANDMARKS_AVAILABLE && typeBefore === 'function') builder = builder.withFaceLandmarks();
    builder = builder.withFaceExpressions().withAgeAndGender();

    const dets = await builder;
    // (debugrad borttagen)

    ctx.clearRect(0,0,overlay.width,overlay.height);

    for (const det of dets){
      const b = det.detection.box; const bbox=[b.x,b.y,b.width,b.height];

      // matchning + smoothing
      let best=null, bestIoU=0;
      for(const t of tracks){ const i=iou(t.bbox,bbox); if(i>bestIoU){bestIoU=i; best=t;} }
      if(best && bestIoU>0.3){
        const pb=best.bbox;
        best.bbox = pb
          ? [ema(pb[0], bbox[0], BBOX_ALPHA),
             ema(pb[1], bbox[1], BBOX_ALPHA),
             ema(pb[2], bbox[2], BBOX_ALPHA),
             ema(pb[3], bbox[3], BBOX_ALPHA)]
          : bbox.slice();
        best.last=now;
      } else {
        const t={ id:nextId++, bbox, last:now, created:now, seenFrames:0, counted:false,
                  peppText:null, ageHist:[], warm:0, contributing:false, effects:null, pose:{},
                  usePose:false, poseValid:0, poseInvalid:0 };
        tracks.push(t); if(overlaysEnabled) assignEffects(t);
      }
      const tr=(best && bestIoU>0.3)? best : tracks[tracks.length-1];

      // emotion/age
      const exp=det.expressions||{}; let emo=null, conf=0; for(const [k,v] of Object.entries(exp)) if(v>conf){ emo=k; conf=v; }
      const shownAge = getSmoothedAge(tr, now, det.age ?? null);

      // pose
      if (det.landmarks){
        const lm = det.landmarks;
        const mean = pts => { const n=pts.length; const s=pts.reduce((a,p)=>({x:a.x+p.x,y:a.y+p.y}),{x:0,y:0}); return {x:s.x/n,y:s.y/n}; };
        const dist = (a,b)=> Math.hypot(a.x-b.x,a.y-b.y);
        const mid  = (a,b)=> ({x:(a.x+b.x)/2, y:(a.y+b.y)/2});

        const Leye = mean(lm.getLeftEye());
        const Reye = mean(lm.getRightEye());
        const eyeC = mid(Leye, Reye);
        const eyeD = dist(Leye, Reye);
        const angle= Math.atan2(Reye.y - Leye.y, Reye.x - Leye.x);

        const mouth = lm.getMouth?.();
        const mL = mouth ? mouth[0] : null;
        const mR = mouth ? mouth[6] : null;
        const mouthC = (mL && mR) ? mid(mL, mR) : null;
        const mouthW = (mL && mR) ? dist(mL, mR) : null;

        const jaw = lm.getJawOutline?.();
        const faceW = jaw ? dist(jaw[0], jaw[16]) : null;

        const pz = tr.pose;
        pz.eyeCx   = ema(pz.eyeCx,   eyeC.x, POSE_ALPHA);
        pz.eyeCy   = ema(pz.eyeCy,   eyeC.y, POSE_ALPHA);
        pz.eyeD    = ema(pz.eyeD,    eyeD,   POSE_ALPHA);
        pz.angle   = ema(pz.angle,   angle,  POSE_ALPHA);
        if (mouthC){ pz.mouthCx = ema(pz.mouthCx, mouthC.x, POSE_ALPHA); pz.mouthCy = ema(pz.mouthCy, mouthC.y, POSE_ALPHA); }
        if (mouthW!=null) pz.mouthW = ema(pz.mouthW, mouthW, POSE_ALPHA);
        if (faceW!=null)  pz.faceW  = ema(pz.faceW,  faceW,  POSE_ALPHA);
      }

      // sticky/hysteresis f√∂r pose-l√§ge
      {
        const validNow = !!det.landmarks && isValidPose(tr.pose, b.width, b.height);
        if (validNow) { tr.poseValid++; tr.poseInvalid=0; if(!tr.usePose && tr.poseValid>=2) tr.usePose=true; }
        else { tr.poseInvalid++; tr.poseValid=0; if(tr.usePose && tr.poseInvalid>=6) tr.usePose=false; }
      }

      // √§cklad boost
      if (det.landmarks) {
        const mar=mouthAspectRatio(det.landmarks), happy=exp.happy||0, neutral=exp.neutral||0;
        if(mar>0.42 && happy<0.4 && neutral<0.6){ if((exp.disgusted||0)<0.6) exp.disgusted=0.6; if(exp.disgusted>=conf){ emo='disgusted'; conf=exp.disgusted; } }
      }

      // logg
      tr.seenFrames++; if(!tr.counted && tr.seenFrames===30){ const key=todayKey(); visitorsByDay[key]=(visitorsByDay[key]||0)+1; localStorage.setItem('moodcam.visitors', JSON.stringify(visitorsByDay)); updateLogInfo(); tr.counted=true; }

      // mood-ackumulator
      if (emo==='happy' && conf>=EMO_CONF_MIN){
        tr.warm += dt;
        if(!tr.contributing && tr.warm>=HAPPY_WARMUP_SECONDS) tr.contributing=true;
        if(tr.contributing){ const wgt = CONTRIB_WEIGHT_BY_CONF ? Math.max(0.5, conf) : 1; HAPPY_PERSON_SECONDS += dt * wgt; }
      } else { tr.warm=0; tr.contributing=false; }

      // rita
      const [x,y,w,h]=tr.bbox, color=EMO_COLOR[emo]||'#24ff78';
      ctx.strokeStyle=color; ctx.lineWidth=UI.faceBoxWidth; ctx.strokeRect(x,y,w,h);
      if(emo && conf>=EMO_CONF_MIN){ const label=`${EMO_SV[emo]||emo} ¬∑ ${Math.round(conf*100)}%` + (shownAge?` ¬∑ ${shownAge} √•r`:''); drawLabel(x,y,label); }
      else if(shownAge){ drawLabel(x,y,`${shownAge} √•r`); }

      // emoji
      const emoji=EMO_EMOJI[emo]||"üôÇ"; const emSize=Math.max(28, Math.round(Math.min(w,h)*0.22));
      ctx.font=`${emSize}px serif`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(emoji, x+w, y);
      ctx.textAlign='left'; ctx.textBaseline='alphabetic';

      // overlays
      drawEffects(tr, x,y,w,h);

      // pepp
      if (peppEnabled){ if(!tr.peppText) tr.peppText = randomPepp(); drawCenteredBottom(x,y,w,h,tr.peppText); }
    }

    // st√§da
    const tnow=performance.now(); for(let i=tracks.length-1;i>=0;i--) if(tnow-tracks[i].last>1500) tracks.splice(i,1);

    // m√§tare
    const targetPct = Math.min(100, 100*(HAPPY_PERSON_SECONDS/METER_GOAL_SECONDS));
    meterShown = meterShown + (targetPct - meterShown) * METER_EASE;
    document.getElementById('meterFill').style.width = Math.max(0,Math.min(100,meterShown)) + '%';
    document.getElementById('meterVal').textContent = Math.round(meterShown);
  } catch(err){
    console.error('[MoodCam] tick() error:', err);
  }
  requestAnimationFrame(tick);
}

/* ---------- Logg / CSV ---------- */
function updateLogInfo(){ const list=Object.entries(visitorsByDay).sort(([a],[b])=>a.localeCompare(b)); const txt=list.length? list.map(([d,n])=>`${d}: ${n}`).join(' ¬∑ ') : 'Ingen logg √§n.'; const el=document.getElementById('logInfo'); if(el) el.textContent=txt; }
function downloadCSV(){ const rows=[['date','visitors'],...Object.entries(visitorsByDay)]; const csv=rows.map(r=>r.join(',')).join('\n'); const blob=new Blob([csv],{type:'text/csv'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='moodcam_visitors.csv'; a.click(); URL.revokeObjectURL(a.href); }

/* ---------- Init ---------- */
(async function init(){
  console.info('[MoodCam] Init‚Ä¶ TFJS:', (tf && tf.version_core)||'n/a', 'face-api:', (faceapi && faceapi.version)||'n/a');

  video=document.getElementById('video'); overlay=document.getElementById('overlay'); ctx=overlay.getContext('2d');

  // UI handlers
  document.getElementById('settingsBtn').addEventListener('click', ()=>{ const s=document.getElementById('settings'); s.style.display=(s.style.display==='none'||!s.style.display)?'block':'none'; });
  document.getElementById('conf').addEventListener('input', e=> EMO_CONF_MIN=parseFloat(e.target.value));
  document.getElementById('inputSize').addEventListener('input', e=> DETECTOR_SIZE=parseInt(e.target.value,10));
  document.getElementById('peppToggle').addEventListener('change', e=> { peppEnabled=e.target.checked; });
  document.getElementById('peppCat').addEventListener('change', e=> { peppCat=e.target.value; });

  ['fBrightness','fContrast','fSaturate','fHue','fTemp'].forEach(id=>{
    document.getElementById(id).addEventListener('input', ()=>{
      video.style.filter =
        `brightness(${fBrightness.value}%) contrast(${fContrast.value}%) saturate(${fSaturate.value}%) hue-rotate(${fHue.value}deg)` +
        ((+fTemp.value!==0)?` sepia(${Math.max(0,+fTemp.value)*0.006}) hue-rotate(${(+fTemp.value*1.2).toFixed(1)}deg) saturate(${(100 + +fTemp.value*0.2).toFixed(1)}%)`:'');
    });
  });
  document.getElementById('filtersReset').addEventListener('click', ()=>{
    fBrightness.value=100; fContrast.value=100; fSaturate.value=100; fHue.value=0; fTemp.value=0;
    const evt=new Event('input'); fBrightness.dispatchEvent(evt);
  });
  fBrightness.dispatchEvent(new Event('input'));

  const themeSel = document.getElementById('themeSel');
  THEMES.forEach(t=>{ const o=document.createElement('option'); o.value=t; o.textContent=t; themeSel.appendChild(o); });
  themeSel.value = selectedTheme;
  themeSel.addEventListener('change', async e=>{
    selectedTheme = e.target.value;
    if (overlaysEnabled) { await loadOverlayManifest(selectedTheme); tracks.forEach(t=>assignEffects(t)); }
  });

  document.getElementById('overlayToggle').addEventListener('change', async e=> {
    overlaysEnabled=e.target.checked;
    if (overlaysEnabled && !overlayManifest) await loadOverlayManifest(selectedTheme);
    tracks.forEach(t=>assignEffects(t));
  });
  document.getElementById('ovHats').addEventListener('change', e=> { overlayUse.hats=e.target.checked; tracks.forEach(t=>assignEffects(t)); });
  document.getElementById('ovGlasses').addEventListener('change', e=> { overlayUse.glasses=e.target.checked; tracks.forEach(t=>assignEffects(t)); });
  document.getElementById('ovEyes').addEventListener('change', e=> { overlayUse.eyes=e.target.checked; tracks.forEach(t=>assignEffects(t)); });
  document.getElementById('ovMouth').addEventListener('change', e=> { overlayUse.mouth=e.target.checked; tracks.forEach(t=>assignEffects(t)); });
  document.getElementById('ovBeard').addEventListener('change', e=> { overlayUse.beard=e.target.checked; tracks.forEach(t=>assignEffects(t)); });

  document.getElementById('dlLog').addEventListener('click', downloadCSV);
  document.getElementById('clearLog').addEventListener('click', ()=> { localStorage.setItem('moodcam.visitors','{}'); for (const k in visitorsByDay) delete visitorsByDay[k]; updateLogInfo(); });

  const goalInput=document.getElementById('goalSec'); const goalLabel=document.getElementById('goalLabel');
  METER_GOAL_SECONDS=parseInt(goalInput.value,10); goalLabel.textContent=METER_GOAL_SECONDS;
  goalInput.addEventListener('input', e=>{ METER_GOAL_SECONDS=parseInt(e.target.value,10); goalLabel.textContent=METER_GOAL_SECONDS; });

  // Kicka ig√•ng laddningar (tyst): meta ja, manifest bara om overlays √§r p√•
  await loadAssetMeta();
  listCams(1);
  ensureModelsLoading(); // i bakgrunden

  // Start-knapp
  document.getElementById('start').addEventListener('click', async ()=>{
    const modelsOK = await ensureModelsLoading(); if (!modelsOK) return;
    const sel=document.getElementById('camSel');
    const ok = await startCamera(sel.value); if (!ok) return;

    new ResizeObserver(()=>{ overlay.width=video.videoWidth; overlay.height=video.videoHeight; overlay.style.width=video.clientWidth+'px'; overlay.style.height=video.clientHeight+'px'; }).observe(document.getElementById('wrap'));
    console.info('[MoodCam] Kamera ig√•ng, startar loop‚Ä¶');
    requestAnimationFrame(tick);
    document.getElementById('start').disabled = true;
  });

  // Global fel-logg (beh√•ll)
  window.addEventListener('error', (e)=> console.error('[MoodCam] window error:', e.error||e.message));
})();
</script>
</body>
</html>
