<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Vialundskolans MoodCam (v.1.5.5)</title>
  <link rel="icon" href="data:,">
<style>
  :root{--bg:#0b0f14;--fg:#e7effa;--panel:#0f172a;--panel2:#111827;--border:#1f2937;--accent:#22c55e}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,sans-serif}
  #stage{display:grid;grid-template-columns:1fr;gap:16px;height:100vh;align-items:center;justify-items:center;padding:12px}

  /* üîß Topbar √∂ver allt och klickbar */
  .topbar{
    position:fixed; top:10px; left:10px; display:flex; gap:8px;
    z-index:9999;                 /* upp fr√•n 10 */
    pointer-events:auto;          /* s√§kerst√§ll klickbar */
  }
  .btn{background:var(--panel2);border:1px solid var(--border);color:var(--fg);padding:8px 12px;border-radius:8px;cursor:pointer}
  .btn:disabled{opacity:.5;cursor:not-allowed}

  .layer-wrap{
    position:relative;display:inline-block;border-radius:12px;overflow:hidden;
    box-shadow:0 12px 36px rgba(0,0,0,.5);max-width:96vw;max-height:86vh
  }

  /* G√∂r canvas till egna kompositionslager (minskar blink vid alpha/transform) */
  .layer-wrap canvas{
    display:block; will-change:transform, opacity; backface-visibility:hidden; contain:paint;
    transform: translateZ(0); /* tvinga GPU-lager */
  }

  /* ‚ùóSpegelv√§nd **composite** (det anv√§ndaren ser), inte <video> */
  .layer-wrap.mirror #composite { transform: translateZ(0) scaleX(-1); }

  /* R√•video: osynlig men deltar i layouten (ingen svart bild / inget glapp) */
  #video{
    visibility:hidden;            /* osynlig men layoutar och spelar */
    position:relative;            /* i normalt fl√∂de s√• wrap f√•r storlek */
    width:100%;
    height:auto;                  /* beh√•ll aspekt, undvik str√§ckning */
    z-index:0;
    pointer-events:none;
  }

  /* üîí Blockera inte klick underlagret */
  .layer-wrap canvas,
  .layer-wrap video {
    pointer-events:none;
  }

  #composite{ position:absolute; inset:0; width:100%; height:100%; z-index:0; }
  #overlay{ position:absolute; inset:0; width:100%; height:100%; pointer-events:none; z-index:1; }

  #meterWrap{
    position:absolute; left:50%; transform:translateX(-50%); bottom:0;
    background:var(--panel); border:1px solid var(--border);
    border-bottom-left-radius:0; border-bottom-right-radius:0;
    border-top-left-radius:10px; border-top-right-radius:10px;
    padding:6px 10px; width:min(360px,70%); z-index:2;
  }
  #meterBar{position:relative;height:8px;background:#0d1218;border-radius:6px;overflow:hidden;border:1px solid var(--border)}
  #meterFill{height:100%;width:0%;background:linear-gradient(90deg,#2dd4bf,#22c55e)}
  .meterVal{position:absolute;right:6px;top:-16px;opacity:.85}
  .small{font-size:12px;opacity:.8}

  /* Paneler √∂ver renderlagren */
  .panel{
    display:none; position:fixed; right:12px; top:52px; width:360px; max-height:85vh; overflow:auto;
    background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:12px 12px 8px;
    z-index:10000; /* upp fr√•n 20 */
  }
  .panel h3{margin:6px 0 8px 0;font-size:16px}
  .panel .row{display:flex;justify-content:space-between;align-items:center;margin:8px 0}
  .panel label{font-size:14px}

  details{border:1px dashed var(--border);border-radius:8px;padding:6px;margin-top:8px}
  summary{cursor:pointer}
  .desc{font-size:12px;opacity:.75;margin:4px 0 0}
  input[type="range"]{width:190px}
  .two-col{display:grid;grid-template-columns:auto 1fr;gap:8px;align-items:center}
  .hud{position:fixed;left:14px;bottom:14px;font-size:12px;opacity:.7}

  /* Enkel markdown-stil f√∂r OM-panelen */
  #aboutBody { font-size:14px; line-height:1.45 }
  #aboutBody h1, #aboutBody h2, #aboutBody h3 { margin: 12px 0 8px }
  #aboutBody code { background:#0d1218; padding:0 4px; border-radius:4px }
  #aboutBody pre { background:#0d1218; padding:8px; border-radius:8px; overflow:auto }
  #aboutBody ul { padding-left: 18px }
  #aboutBody a { color: var(--fg); text-decoration: underline }
</style>


<script>
  /* ---------- Konsolfilter ---------- */
  const ORIG_CONSOLE = { info: console.info, warn: console.warn, log: console.log };
  const NOISE_PATTERNS = [/already been set/i,/backend was already registered/i,/kernel .* already registered/i,/Reusing existing backend factory/i];
  console.warn = (...a)=>{ const s=(a||[]).join(' '); if (NOISE_PATTERNS.some(r=>r.test(s))) return; ORIG_CONSOLE.warn.apply(console,a); };
  console.info = (...a)=>{ const s=(a||[]).join(' '); if (NOISE_PATTERNS.some(r=>r.test(s))) return; ORIG_CONSOLE.info.apply(console,a); };
</script>
  <!-- Libs -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.21.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@4.21.0/dist/tf-backend-wasm.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api/dist/face-api.min.js"></script>
  <script defer src="./vendor/mediapipe/selfie_segmentation/selfie_segmentation.js"></script>

</head>
<body>
  <div class="topbar">
    <button id="start" class="btn">Starta kamera</button>
    <button id="settingsBtn" class="btn" aria-label="√ñppna inst√§llningar">Settings</button>
    <button id="aboutBtn" class="btn" aria-label="Om den h√§r appen">OM</button>
  </div>

  <div id="stage">
    <div class="layer-wrap" id="wrap">
      <video id="video" autoplay muted playsinline></video>
      <canvas id="composite"></canvas>
      <canvas id="overlay"></canvas>

      <div id="meterWrap">
        <div id="meterBar">
          <div id="meterFill"></div>
          <span id="meterVal" class="small meterVal" aria-live="polite">0</span>
        </div>
        <div class="small" style="margin-top:2px">
          Moodm√§tare ‚Äì B√∂rjar √∂ka efter <em>1s</em>, s√• SMILE üòÑ
        </div>
      </div>

      <!-- Ghost video: helt dold + f√∂rladdad -->
      <video id="ghost" playsinline muted preload="auto" style="display:none"></video>
    </div>
  </div>

  <!-- Settings-panelen -->
  <div id="settings" class="panel">
    <h3>Settings</h3>
    <p id="verInfo" class="small" style="margin:0 0 6px 0; opacity:.9"></p>

    <!-- ‚ú® Prestandal√§ge -->
    <div class="row">
      <label for="perfMode">Prestandal√§ge</label>
      <select id="perfMode" class="btn" style="width:220px">
        <option value="standard" selected>Standard</option>
        <option value="light">Light (svagare dator)</option>
      </select>
    </div>

    <div class="row">
      <label for="camSel">Kamera</label>
      <select id="camSel" class="btn" style="width:220px"></select>
    </div>
    <div class="row">
      <label for="conf">Konfidens (etikett)</label>
      <input id="conf" type="range" min="0.2" max="0.9" step="0.05" value="0.40">
    </div>
    <div class="row">
      <label for="inputSize">Detector size</label>
      <input id="inputSize" type="range" min="224" max="512" step="32" value="320">
    </div>
    <div class="row">
      <label for="score">Detektor-tr√∂skel</label>
      <input id="score" type="range" min="0.40" max="0.80" step="0.01" value="0.60">
    </div>

    <details>
      <summary>Peppande one-liners</summary>
      <div class="row" style="margin-top:8px">
        <label>Aktivera</label><input type="checkbox" id="peppToggle" checked>
      </div>
      <div class="row">
        <label for="peppCat">Kategori</label>
        <select id="peppCat" class="btn" style="width:220px"></select>
      </div>
      <p class="desc">Visas i varje ansiktsruta, l√•ses per person tills de l√§mnar bild. Kategorier och texter l√§ses fr√•n <code>pepp.json</code>.</p>
    </details>

    <details>
      <summary>Overlays & teman</summary>
      <div class="row">
        <!-- ‚õîÔ∏è AV fr√•n start -->
        <label>Aktivera overlays</label><input type="checkbox" id="overlayToggle">
      </div>
      <div class="row">
        <label for="themeSel">Tema</label>
        <select id="themeSel" class="btn" style="width:220px"></select>
      </div>
      <div class="row"><label>Hattar</label><input type="checkbox" id="ovHats"></div>
      <div class="row"><label>Glas√∂gon</label><input type="checkbox" id="ovGlasses" checked></div>
      <div class="row"><label>√ñgon</label><input type="checkbox" id="ovEyes"></div>
      <div class="row"><label>Munnar</label><input type="checkbox" id="ovMouth"></div>
      <div class="row"><label>Sk√§gg</label><input type="checkbox" id="ovBeard"></div>
      <div class="row"><label>Visa ansiktsruta</label><input type="checkbox" id="showBox"></div>
      <p class="desc">Tema anger *vilka filer*; passform kommer fr√•n <code>img/assets/meta.json</code>.</p>
    </details>

    <details>
      <summary>Kamera ‚Äì bild (filter)</summary>
      <div class="two-col">
        <label for="fBrightness">Ljusstyrka</label><input id="fBrightness" type="range" min="50" max="150" step="1" value="100">
        <label for="fContrast">Kontrast</label><input id="fContrast" type="range" min="50" max="150" step="1" value="100">
        <label for="fSaturate">M√§ttnad</label><input id="fSaturate" type="range" min="0"  max="200" step="1" value="100">
        <label for="fHue">Ton (¬∞)</label><input id="fHue" type="range" min="-180" max="180" step="1" value="0">
        <label for="fTemp">F√§rgtemperatur</label><input id="fTemp" type="range" min="-50" max="50" step="1" value="0">
        <label for="mirrorX">Spegelv√§nd bild</label><input id="mirrorX" type="checkbox" checked>
      </div>
      <div class="row"><button id="filtersReset" class="btn">√Öterst√§ll</button></div>
      <p class="desc">P√•verkar bara visningen (inte detekteringen).</p>
    </details>

    <details>
      <summary>Bes√∂kslogg</summary>
      <div class="row" style="margin-top:8px">
        <button id="dlLog" class="btn">Ladda ner CSV</button>
        <button id="clearLog" class="btn" style="background:#581c1c;border-color:#7f1d1d">Nollst√§ll</button>
      </div>
      <p id="logInfo" class="small"></p>
    </details>

    <details>
      <summary>Bakgrundseffekt</summary>
      <!-- ‚õîÔ∏è AV fr√•n start -->
      <div class="row"><label>Aktivera</label><input type="checkbox" id="ghostToggle"></div>
      <div class="row">
        <label for="ghostMode">Frekvens</label>
        <select id="ghostMode" class="btn" style="width:220px">
          <option value="rare" selected>S√§llan</option>
          <option value="sometimes">Ibland</option>
          <option value="often">Ofta</option>
        </select>
      </div>
      <div class="row">
        <label for="ghostFacesOnly">Bara n√§r n√•gon syns</label><input type="checkbox" id="ghostFacesOnly" checked>
      </div>
      <div class="row">
        <label for="ghostBgAlpha">Bakgrundsgenomskinlighet</label>
        <input id="ghostBgAlpha" type="range" min="0" max="100" step="1" value="88">
      </div>
      <div class="row">
        <label for="ghostMirrorX">Spegelv√§nd sp√∂kvideon</label><input type="checkbox" id="ghostMirrorX">
      </div>
      <div class="row">
        <label for="ghostAlpha">Sp√∂kvideo-transparens</label>
        <input id="ghostAlpha" type="range" min="0" max="100" step="1" value="0">
      </div>
      <p class="desc">0% = ingen transparens (sp√∂ket opakt). 100% = helt osynligt.</p>
      <div class="row">
        <label for="ghostFade">Fade in/ut</label><input type="checkbox" id="ghostFade" checked>
      </div>
      <div class="row">
        <button id="ghostNow" class="btn">Spela sp√∂ke nu üëª</button>
      </div>
      <p class="desc">Spelar korta klipp ‚Äúbakom‚Äù personlagret. Personerna √§r alltid opaka.</p>
    </details>

    <details>
      <summary>Moodm√§tare ‚Äì m√•l</summary>
      <div class="row">
        <label for="goalSec">M√•l (sekunder glad-tid)</label>
        <input id="goalSec" type="range" min="300" max="3600" step="60" value="300">
      </div>
      <p class="small">Nuvarande m√•l: <span id="goalLabel">300</span> s</p>
    </details>
  </div>

  <!-- OM-panel som l√§ser in README.md -->
  <div id="about" class="panel" aria-modal="true" role="dialog">
    <h3>Om MoodCam</h3>
    <div id="aboutBody" class="small">Laddar dokumentation‚Ä¶</div>
  </div>

  <div class="hud">Allt k√∂rs lokalt i datorn. /Kristoffer</div>

<script>
const DEBUG = false;

// ---- DEBUG HELPERS ----
let __frame = 0;
const every = (n, fn) => { __frame++; if (__frame % n === 0) fn(); };
const tag = (t, ...a) => console.log(`[${t}]`, ...a);


/* ---------- Konstanter & state ---------- */
const EMO_SV = { angry:"Arg", disgusted:"√Ñcklad", fearful:"R√§dd", happy:"Glad", neutral:"Neutral", sad:"Ledsen", surprised:"F√∂rv√•nad" };
const EMO_EMOJI = { angry:"üò°", disgusted:"ü§¢", fearful:"üò®", happy:"üòÑ", neutral:"üòê", sad:"üò¢", surprised:"üòÆ" };
const EMO_COLOR = { happy:"#28c728", angry:"#2a2ae0", sad:"#c07800", surprised:"#c0c000", fearful:"#00b4b4", disgusted:"#00a078", neutral:"#b0b0b0" };
const UI = { labelFontSize:16, labelPad:4, pepFontSize:16, pepPad:4, faceBoxWidth:2 };

/* --- Nu styrs dessa √§ven av preset --- */
let EMO_CONF_MIN = 0.40;
let DETECTOR_SIZE = 320;
let DETECTOR_SCORE = 0.60;
let MAX_FACES = 4;
let FRAME_SKIP_N = 0;
let USE_LANDMARKS = true;
let SEG_EVERY_N = 1;
let SEG_ENABLED = true;

let peppEnabled = true;
let peppCat = 'all';
let PEPP = {};
let PEPP_KEYS = [];

const THEMES = ["Aktivt (img/manifest.json)","halloween","jul","sommar","skolstart","test"];
let selectedTheme = THEMES[0];

let overlaysEnabled = false;
/* ‚ùóStartl√§ge synkas i init() fr√•n checkboxar ‚Äì defaulta allt till false h√§r */
const overlayUse = { hats:false, glasses:false, eyes:false, mouth:false, beard:false };

let overlayManifest = null;
const imgCache = new Map();

let assetMeta = {};
async function loadAssetMeta(){
  try{
    const r = await fetch('./img/assets/meta.json', {cache:'no-store'});
    if (r.ok) assetMeta = await r.json();
  }catch(e){ if (DEBUG) console.warn('[MoodCam] assets/meta.json saknas/ol√§slig', e); }
}

let LANDMARKS_AVAILABLE = false;

let video, overlay, ctx, currentStream=null;
let composite, compCtx; // f√∂r sp√∂k-komposit
let ghostEl;

/* Tracks */
const tracks = [];
let nextId = 1;

let lastFrameTime = performance.now();

/* Mood-meter */
let HAPPY_PERSON_SECONDS = 0;
let METER_GOAL_SECONDS = 300;
let meterShown = 0;
const METER_EASE = 0.07;
const HAPPY_WARMUP_SECONDS = 1;
const CONTRIB_WEIGHT_BY_CONF = true;

const RESET_H = 19, RESET_M = 30;

/* Jitter-filter */
const POSE_ALPHA = 0.15;
const BBOX_POS_ALPHA  = 0.35;
const BBOX_SIZE_ALPHA = 0.75;
const ema = (prev, next, a)=> (prev==null? next : prev + a*(next - prev));

/* Spegeltillst√•nd */
let MIRROR = true;

/* Visa/d√∂lj ansiktsruta ‚Äì default: osynlig */
let SHOW_FACE_BOX = false;

/* Adaptiv input */
const FRAME_OPTS = { ADAPTIVE_INPUT: true, MANY_FACES_THRESHOLD: 3, LOW_INPUT_SIZE: 288 };
let FRAME_I = 0;

/* Logg */
const visitorsByDay = JSON.parse(localStorage.getItem('moodcam.visitors') || '{}');
updateLogInfo();
const AGE_SMOOTH_WINDOW_MS = 10_000;

/* FPS-adaption f√∂r mask */
let fpsEMA = 30;
const FPS_EMA_A = 0.08;
const LOW_FPS_OFF = 10;
const HIGH_FPS_ON = 14;

/* ---------- Hj√§lp ---------- */
function todayKey(){ const d=new Date(); return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`; }
function scheduleResetIfNeeded(){ const now=new Date(); const reset=new Date(); reset.setHours(RESET_H, RESET_M, 0, 0); if (Math.abs(now-reset)<1000){ HAPPY_PERSON_SECONDS=0; meterShown=0; } }
function iou(a,b){
  const [ax,ay,aw,ah] = a, [bx,by,bw,bh] = b;
  const x1 = Math.max(ax, bx), y1 = Math.max(ay, by);
  const x2 = Math.min(ax + aw, bx + bw), y2 = Math.min(ay + ah, by + bh);
  const inter = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
  const union = aw * ah + bw * bh - inter;
  return union > 0 ? inter / union : 0;
}

function mirrorX(x, w=0){ return MIRROR ? (overlay.width - (x + w)) : x; }

function drawLabel(x,y,text){
  ctx.font = `${UI.labelFontSize}px system-ui`; ctx.textAlign='left'; ctx.textBaseline='alphabetic';
  const pad=UI.labelPad, h=UI.labelFontSize*1.2, w=ctx.measureText(text).width;
  ctx.fillStyle='rgba(0,0,0,0.85)'; ctx.fillRect(x-pad,y-h-pad,w+pad*2,h+pad*2);
  ctx.fillStyle='#fff'; ctx.fillText(text,x,y);
}
function drawCenteredBottom(x,y,w,h,text){
  if (!text) return;
  ctx.font = `${UI.pepFontSize}px system-ui`; ctx.textAlign='left'; ctx.textBaseline='alphabetic';
  const pad=UI.pepPad, htxt=UI.pepFontSize*1.2, tw=ctx.measureText(text).width, cx=x+w/2-tw/2, cy=y+h-8;
  ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(cx-pad,cy-htxt-pad,tw+pad*2,htxt+pad*2);
  ctx.fillStyle='#fff'; ctx.fillText(text,cx,cy);
}
function syncOverlaySize(){
  overlay.width  = video.videoWidth;
  overlay.height = video.videoHeight;
  composite.width  = video.videoWidth;
  composite.height = video.videoHeight;

  const wrapEl = document.getElementById('wrap');
  const rect = wrapEl.getBoundingClientRect();
  overlay.style.width  = rect.width + 'px';
  overlay.style.height = rect.height + 'px';
  composite.style.width  = rect.width + 'px';
  composite.style.height = rect.height + 'px';
}

/* üîß Canvas-filter (s√• reglagen p√•verkar bilden som syns) */
let CAM_FILTER = 'none';
function buildCamFilterString() {
  const get = (id, def) => {
    const el = document.getElementById(id);
    return el ? +el.value : def;
  };
  const b = get('fBrightness', 100);
  const c = get('fContrast',   100);
  const s = get('fSaturate',   100);
  const h = get('fHue',          0);
  const t = get('fTemp',         0);

  const temp = t !== 0
    ? ` sepia(${Math.max(0, t) * 0.006}) hue-rotate(${(t * 1.2).toFixed(1)}deg) saturate(${(100 + t * 0.2).toFixed(1)}%)`
    : '';

  return `brightness(${b}%) contrast(${c}%) saturate(${s}%) hue-rotate(${h}deg)` + temp;
}
function drawVideoWithFilter(ctx, dx, dy, dw, dh) {
  ctx.save();
  ctx.filter = CAM_FILTER;
  ctx.drawImage(video, dx, dy, dw, dh);
  ctx.restore();
}

/* üîß √Ñndrat: d√∂lj √•ldern tills glidande medelv√§rde finns */
function getSmoothedAge(track, now, latestAge){
  if (latestAge!=null && !Number.isNaN(latestAge)) track.ageHist.push({t:now,a:latestAge});
  const cutoff=now-AGE_SMOOTH_WINDOW_MS; while (track.ageHist.length && track.ageHist[0].t<cutoff) track.ageHist.shift();
  if ((now - track.created) < AGE_SMOOTH_WINDOW_MS) return null;
  if (!track.ageHist.length) return null;
  const avg=track.ageHist.reduce((s,p)=>s+p.a,0)/track.ageHist.length; return Math.round(avg);
}

/* ---------- Pepp (extern) ---------- */
async function loadPepp(){
  try{
    const r = await fetch('./pepp.json', {cache:'no-store'});
    if(!r.ok) throw new Error('Kunde inte l√§sa pepp.json');
    const data = await r.json();
    const ok = Object.fromEntries(
      Object.entries(data).filter(([k,v]) => Array.isArray(v))
                          .map(([k,v]) => [k, v.filter(x => typeof x === 'string')])
    );
    PEPP = ok; PEPP_KEYS = Object.keys(PEPP);
    populatePeppCategories();
  }catch(e){
    console.error('[MoodCam] pepp.json fel:', e);
    PEPP = {}; PEPP_KEYS = [];
    populatePeppCategories();
  }
}
function populatePeppCategories(){
  const sel = document.getElementById('peppCat');
  sel.innerHTML = '';
  if (PEPP_KEYS.length){
    const oAll=document.createElement('option'); oAll.value='all'; oAll.textContent='Alla'; sel.appendChild(oAll);
  }
  PEPP_KEYS.sort().forEach(k=>{
    const o=document.createElement('option'); o.value=k; o.textContent=k; sel.appendChild(o);
  });
  peppCat = (PEPP_KEYS.length ? 'all' : '');
  sel.value = peppCat || (PEPP_KEYS[0] || '');
}
function randomPepp(){
  if (!peppEnabled || !PEPP_KEYS.length) return '';
  const pool = (peppCat === 'all' || !peppCat) ? PEPP_KEYS.flatMap(k => PEPP[k] || []) : (PEPP[peppCat] || []);
  if (!pool.length) return '';
  return pool[Math.floor(Math.random()*pool.length)];
}

/* --------- Overlays & teman --------- */
async function loadOverlayManifest(themeName){
  overlayManifest=null;
  let url = (!themeName || themeName === THEMES[0]) ? './img/manifest.json' : `./img/tema/${themeName}/manifest.json`;
  try{
    const resp=await fetch(url,{cache:'no-store'}); if(!resp.ok) return;
    const data=await resp.json();
    if (!data.facial_hair && data.faceal_hair) data.facial_hair = data.faceal_hair;
    for (const cat of ["hats","glasses","eyes","mouth","facial_hair"]) {
      const src = data[cat] || [];
      data[cat] = src.map(it => (typeof it === 'string' ? { file: it } : it));
    }
    overlayManifest = data;
    const toLoad=[];
    for (const cat of ["hats","glasses","eyes","mouth","facial_hair"]) {
      (data[cat]||[]).forEach(item=>{
        const path = `./img/${item.file}`;
        if(!imgCache.has(path)){
          const im = new Image();
          im.src = path;
          imgCache.set(path, im);
          toLoad.push(im.decode?.() ?? new Promise(r=>{im.onload=r;im.onerror=r;}));
        }
      });
    }
    await Promise.all(toLoad);
  } catch(e){ if (DEBUG) console.warn('[MoodCam] Overlay manifest kunde inte laddas', e); }
}
function choiceWeighted(arr){
  if(!arr || !arr.length) return null;
  const weights = arr.map(o => (o.prob ?? 1));
  const sum = weights.reduce((a,b)=>a+b,0);
  let r = Math.random()*sum;
  for (let i=0;i<arr.length;i++){ r -= weights[i]; if (r <= 0) return arr[i]; }
  return arr[arr.length-1];
}
function assignEffects(track){
  if(!overlaysEnabled || !overlayManifest){ track.effects=null; return; }
  const e={};
  if (overlayUse.hats) e.hat = choiceWeighted(overlayManifest.hats) || null;
  if (overlayUse.eyes && overlayUse.glasses) {
    const pickEyes = Math.random() < 0.5;
    if (pickEyes) e.eyes = choiceWeighted(overlayManifest.eyes) || null;
    else          e.glass = choiceWeighted(overlayManifest.glasses) || null;
  } else {
    if (overlayUse.eyes)    e.eyes  = choiceWeighted(overlayManifest.eyes) || null;
    if (overlayUse.glasses) e.glass = choiceWeighted(overlayManifest.glasses) || null;
  }
  if (overlayUse.mouth) e.mouth = choiceWeighted(overlayManifest.mouth) || null;
  if (overlayUse.beard) e.beard = choiceWeighted(overlayManifest.facial_hair) || null;
  track.effects = e;
}

/* ---- Pose sanity (bbox-medveten) ---- */
function isValidPose(p, box){
  if (!p || !box) return false;
  const {x, y, width: w, height: h} = box;
  const ok = v => Number.isFinite(v);
  if (!ok(p.eyeCx)||!ok(p.eyeCy)||!ok(p.eyeD)) return false;
  const ex = p.eyeCx - x; const ey = p.eyeCy - y;
  const minEyeD = Math.max(6, Math.min(w,h)*0.06);
  const maxEyeD = Math.min(w*0.9, Math.min(w,h)*0.8);
  if (!(p.eyeD > minEyeD && p.eyeD < maxEyeD)) return false;
  if (ok(p.mouthW) && !(p.mouthW > minEyeD*0.6 && p.mouthW < w*1.2)) return false;
  if (!(ex >= -w*0.2 && ex <= w*1.2 && ey >= -h*0.2 && ey <= h*1.2)) return false;
  return true;
}
function defaultFitForFile(path){
  if (path.startsWith('assets/glasses/'))     return 'glasses';
  if (path.startsWith('assets/eyes/'))        return 'eyes';
  if (path.startsWith('assets/mouth/'))       return 'mouth';
  if (path.startsWith('assets/facial_hair/')) return 'beard';
  if (path.startsWith('assets/hats/'))        return 'hat';
  return 'bbox';
}
function drawItem(meta, track, x,y,w,h){
  if(!meta) return;
  const path = `./img/${meta.file}`;
  const img = imgCache.get(path); if(!img) return;
  const iw = (img.width || img.naturalWidth || 1);
  const ih = (img.height || img.naturalHeight || 1);
  const mAsset = assetMeta[meta.file] || {};
  const cfg = { ...meta, ...mAsset };
  const fit = (cfg.fit || defaultFitForFile(cfg.file));
  const flipX = !!cfg.flipX;
  const rotWithEyes = (cfg.rot !== false);
  if (!track.usePose) return;
  const p = track.pose;
  let eyeC = {x:p.eyeCx, y:p.eyeCy};
  let eyeD = p.eyeD;
  if (!Number.isFinite(eyeC.x) || !Number.isFinite(eyeC.y) || !Number.isFinite(eyeD)) return;
  let angle= p.angle || 0;
  let mouthC = (p.mouthCx!=null && p.mouthCy!=null) ? {x:p.mouthCx, y:p.mouthCy} : {x:eyeC.x, y:eyeC.y + eyeD*0.6};
  const mouthW = p.mouthW || eyeD*0.9;
  const faceW  = p.faceW  || w;
  if (MIRROR){ eyeC = { x: overlay.width - eyeC.x, y: eyeC.y }; mouthC = { x: overlay.width - mouthC.x, y: mouthC.y }; angle = -angle; }
  let cx, cy, refW, defWF=1.0, defY=0, defX=0;
  if (fit==='eyes' || fit==='glasses'){ cx=eyeC.x; cy=eyeC.y; refW=eyeD; defWF=(fit==='eyes')?2.2:2.0; defY=(fit==='eyes')?0.15:0.05; }
  else if (fit==='mouth'){ cx=mouthC.x; cy=mouthC.y; refW=mouthW; defWF=1.3; }
  else if (fit==='beard'){ cx=mouthC.x; cy=mouthC.y + eyeD*0.55; refW=faceW; defWF=0.9; defY=0.05; }
  else if (fit==='hat'){ cx=eyeC.x; cy=eyeC.y - eyeD*0.9; refW=faceW; defWF=1.1; defY=-0.15; }
  else { return; }
  const wf = (cfg.wFactor ?? defWF);
  const drawW = refW * wf;
  const drawH = drawW * (ih/iw);
  const dx = (cfg.xOffset || defX) * refW;
  const dy = ((cfg.yOffset !== undefined ? cfg.yOffset : defY)) * refW;
  ctx.save();
  if (rotWithEyes){
    ctx.translate(cx + dx, cy + dy);
    if (flipX) ctx.scale(-1,1);
    ctx.rotate(angle);
    ctx.drawImage(img, -drawW/2, -drawH/2, drawW, drawH);
  } else {
    const px = cx + dx - drawW/2, py = cy + dy - drawH/2;
    if (flipX){ ctx.translate(px+drawW/2, py+drawH/2); ctx.scale(-1,1); ctx.drawImage(img,-drawW/2,-drawH/2,drawW,drawH); }
    else ctx.drawImage(img, px, py, drawW, drawH);
  }
  ctx.restore();
}
function drawEffects(track,x,y,w,h){
  if(!overlaysEnabled || !track.effects) return;
  const e=track.effects;
  if (e.eyes)  drawItem(e.eyes,  track, x,y,w,h);
  if (e.glass) drawItem(e.glass, track, x,y,w,h);
  if (e.mouth) drawItem(e.mouth, track, x,y,w,h);
  if (e.beard) drawItem(e.beard, track, x,y,w,h);
  if (e.hat)   drawItem(e.hat,   track, x,y,w,h);
}

/* ---------- Kamera ---------- */
async function listCams(defaultIndex=0){
  const sel = document.getElementById('camSel');
  sel.innerHTML = '';
  try{
    const devices = (await navigator.mediaDevices.enumerateDevices()).filter(d => d.kind === 'videoinput');
    devices.forEach((d,i)=>{
      const o=document.createElement('option'); o.value=d.deviceId||''; o.textContent=d.label||`Kamera ${i+1}`; sel.appendChild(o);
    });
    if (!sel.value && devices.length) sel.selectedIndex = Math.min(defaultIndex, devices.length-1);
  }catch(e){ if (DEBUG) console.warn('[MoodCam] enumerateDevices fel', e); }
}
async function startCamera(deviceId){
  try{
    if (currentStream) currentStream.getTracks().forEach(t => t.stop());

    const base = { width:{ideal:1280}, height:{ideal:720}, frameRate:{ideal:30}, facingMode:'user' };
    const constraints = { audio:false, video: deviceId ? { ...base, deviceId:{ exact: deviceId } } : base };
    currentStream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = currentStream;
    await new Promise(r=>{ const f=()=>{video.removeEventListener('loadedmetadata',f); r();}; if(video.readyState>=1) r(); else video.addEventListener('loadedmetadata',f); });
    await video.play().catch(()=>{});
    syncOverlaySize();
    return true;
  }catch(err){
    console.error('[MoodCam] getUserMedia failed', err);
    alert('Kunde inte starta kameran.\n' + (err.name?`${err.name}: `:'') + (err.message||'Ok√§nt fel.') + '\nTips: k√∂r √∂ver HTTPS/localhost och st√§ng andra appar som anv√§nder kameran.');
    return false;
  }
}

/* ---------- Modeller ---------- */
let modelsPromise=null;
function ensureModelsLoading(){
  if (modelsPromise) return modelsPromise;
  modelsPromise = (async ()=>{
    console.info('[MoodCam] Laddar modeller ‚Ä¶');
    console.time('[MoodCam] Modeller klara');
    try{
      const base='./models/';
      await faceapi.nets.tinyFaceDetector.load(base);
      await faceapi.nets.faceExpressionNet.load(base);
      await faceapi.nets.ageGenderNet.load(base);
      try{
        await faceapi.nets.faceLandmark68Net.load(base);
        LANDMARKS_AVAILABLE=true;
        console.info('[MoodCam] Landmarks aktiverade');
      }catch(e){
        LANDMARKS_AVAILABLE=false;
        if (DEBUG) console.warn('[MoodCam] Landmarks kunde inte laddas:', e);
      }
      console.timeEnd('[MoodCam] Modeller klara');
      return true;
    }catch(e){
      console.error('[MoodCam] Kunde inte l√§sa in modeller', e);
      alert('Kunde inte l√§sa in AI-modellerna fr√•n /models/. Kontrollera att mappen /models/ finns och att filerna √§r √•tkomliga.');
      return false;
    }
  })();
  return modelsPromise;
}

/* ---------- Sp√∂k-komposit ---------- */
let ghostEnabled = false;           // ‚õîÔ∏è AV fr√•n start
let ghostFacesOnly = true;
let ghostMode = 'rare';
let ghostAvgSec = 3600;

/* Bakgrundens opacitet (0..1) i mask-l√§ge */
let ghostBgAlpha = 0.88;

/* Spegling & transparens f√∂r sp√∂ket */
let ghostMirror = false;
/* UI anger TRANSPARENS i %, vi omvandlar till OPACITET: opacity = 1 - transparencyPct/100 */
let ghostTransparencyPct = 0; // 0% transparens = helt opak
let ghostOpacity = 1.0;       // derived

/* Fade */
let ghostFadeEnabled = true;
let ghostFade = 0;            // 0..1
const GHOST_FADE_SPEED = 0.08;

/* Klipp */
let GHOST_CLIPS = ['ghosts/penny1.mp4'];

let seg=null, segReady=false, latestMask=null, segBusy=false;
let playingGhost=false, lastGhostTs=0;
let minGapMs=120000;

function modeToAvgSec(m){ if (m==='rare') return 3600; if (m==='often') return 600; return 1800; }

/* ‚ñ∂Ô∏è V√§lj klipp & spela */
function pickGhost(){ return GHOST_CLIPS[Math.floor(Math.random()*GHOST_CLIPS.length)]; }
async function playGhostOnce(force=false){
  // üõ°Ô∏è Spela inte f√∂rr√§n vi har en mask ‚Äî d√• garanteras att personen kan ritas framf√∂r
  if (!latestMask) { tag('Ghost','avbryter: ingen mask √§n'); return; }

  if (!force) {
    if (!ghostEnabled)  { tag('Ghost', 'avst√§ngd'); return; }
    if ((performance.now() - lastGhostTs) < minGapMs) { tag('Ghost','f√∂r t√§tt inp√•'); return; }
    if (ghostFacesOnly && (window.__lastFaceCount||0) === 0) { tag('Ghost','inga ansikten (blockerad)'); return; }
  }
  if (playingGhost)   { tag('Ghost', 'spelar redan'); return; }
  if (!GHOST_CLIPS.length){ tag('Ghost','inga klipp'); return; }

  const src = pickGhost();
  tag('Ghost', force ? 'startar (FORCE)' : 'startar', src);
  ghostEl.src = src;
  ghostEl.loop = false;
  ghostEl.currentTime = 0;

  ghostFade = ghostFadeEnabled ? 0 : 1;

  try {
    await ghostEl.play();
    playingGhost = true;
    tag('Ghost', 'play() OK');
  } catch (err) {
    playingGhost = false;
    console.error('[Ghost] play() fel', err);
    return;
  }

  const end = () => {
    tag('Ghost','ended');
    ghostEl.pause();
    ghostEl.currentTime = 0;
    playingGhost = false;
    lastGhostTs = performance.now();
    ghostEl.removeEventListener('ended', end);
    ghostFade = 0; // reset
  };
  ghostEl.addEventListener('ended', end);
}

function maybeTriggerGhost(now){
  if (!ghostEnabled || !segReady) return;
  if (playingGhost) return;
  if ((now - lastGhostTs) < minGapMs) return;
  if (ghostFacesOnly && (window.__lastFaceCount||0) === 0) return;
  const avg = ghostAvgSec, pPerSec = 1 / Math.max(avg, 10), dtSec = 1/60;
  if (Math.random() < pPerSec * dtSec) playGhostOnce();
}

/* Hj√§lpare: rita ghostEl med ev. spegel (respekterar dx/dy) */
function drawGhostImage(ctx, dx, dy, dw, dh){
  ctx.save();
  ctx.filter = CAM_FILTER; // matcha live-videons filter
  if (ghostMirror){
    ctx.translate(dx + dw, dy);
    ctx.scale(-1, 1);
    ctx.drawImage(ghostEl, 0, 0, dw, dh);
  } else {
    ctx.drawImage(ghostEl, dx, dy, dw, dh);
  }
  ctx.restore();
}

/* üîÑ Mjuk √∂verg√•ng f√∂r bakgrundens alpha */
let bgAlphaShown = 1.0;
const BG_EASE = 0.18;
let lastHadGhostFrame = false;

/* Rita kompositen */
function compositeFrame(){
  if (!composite || !compCtx || !video) return;
  if (video.readyState < 2) return;

  if (composite.width !== video.videoWidth || composite.height !== video.videoHeight){
    syncOverlaySize();
    tag('Draw','resize', composite.width, composite.height);
  }

  compCtx.clearRect(0,0,composite.width,composite.height);

  const hasGhost = (!ghostEl.paused && !ghostEl.ended);
  const hasGhostFrame = hasGhost && ghostEl.readyState >= 2 && ghostEl.currentTime > 0.02;
  const hasMask  = !!latestMask;
  const useMask  = SEG_ENABLED && hasMask;

  /* --- Fade-uppdatering --- */
  if (ghostFadeEnabled){
    if (hasGhost) ghostFade = Math.min(1, ghostFade + GHOST_FADE_SPEED);
    else          ghostFade = Math.max(0, ghostFade - GHOST_FADE_SPEED);
  } else {
    ghostFade = hasGhost ? 1 : 0;
  }

  /* Vid f√∂rsta riktiga ghost-framen: hoppa direkt till m√•l-alpha f√∂r bakgrunden
     f√∂r att undvika en enstaka ‚Äúfull-bright‚Äù frame. */
  if (hasGhostFrame && !lastHadGhostFrame) {
    bgAlphaShown = ghostBgAlpha;
  }
  lastHadGhostFrame = hasGhostFrame;

  /* --- Mjuk bakgrundsniv√• (1.0 -> ghostBgAlpha) --- */
  const targetBg = (hasGhost && ghostFade > 0.02)
    ? (hasGhostFrame ? ghostBgAlpha : bgAlphaShown)  // h√•ll kvar niv√•n tills f√∂rsta riktiga ghost-frame
    : 1.0;
  bgAlphaShown += (targetBg - bgAlphaShown) * BG_EASE;

  /* --- MASK-l√§ge: Ghost ‚Üí Bakgrund (alpha) ‚Üí Person (alltid opak) --- */
  if (useMask) {
    // 1) Sp√∂ket bakom (v√§nta p√• riktigt frame)
    if (hasGhostFrame && ghostFade > 0 && ghostOpacity > 0){
      compCtx.save();
      compCtx.globalAlpha = ghostFade * ghostOpacity;
      drawGhostImage(compCtx, 0, 0, composite.width, composite.height);
      compCtx.restore();
    }

    // 2) Bakgrund (livevideo) ‚Äì mjuk alpha
    compCtx.save();
    compCtx.globalAlpha = Math.max(0, Math.min(1, bgAlphaShown));
    drawVideoWithFilter(compCtx, 0, 0, composite.width, composite.height);
    compCtx.restore();

    // 3) Person-lagret (alltid opakt)
    try {
      const personCanvas = composite.__personCanvas || (composite.__personCanvas = document.createElement('canvas'));
      if (personCanvas.width !== composite.width || personCanvas.height !== composite.height){
        personCanvas.width = composite.width; personCanvas.height = composite.height;
      }
      const pctx = personCanvas.getContext('2d');
      pctx.clearRect(0,0,personCanvas.width,personCanvas.height);

      // 3a) Rita masken
      pctx.drawImage(latestMask, 0, 0, personCanvas.width, personCanvas.height);
      // 3b) Beh√•ll bara d√§r masken finns (person)
      pctx.globalCompositeOperation = 'source-in';
      drawVideoWithFilter(pctx, 0, 0, personCanvas.width, personCanvas.height);
      // 3c) L√§gg p√• person-lagret opakt
      pctx.globalCompositeOperation = 'source-over';
      compCtx.drawImage(personCanvas, 0, 0);

    } catch (e) {
      console.warn('[MoodCam] Mask-render fel, fallback:', e);
      drawVideoWithFilter(compCtx, 0, 0, composite.width, composite.height);
    }

  } else {
    /* --- FALLBACK: Live ‚Üí Sp√∂k-overlay (person kan inte maskas) --- */
    drawVideoWithFilter(compCtx, 0, 0, composite.width, composite.height);

    if (hasGhostFrame && ghostFade > 0 && ghostOpacity > 0) {
      compCtx.save();
      compCtx.globalAlpha = ghostFade * ghostOpacity;
      drawGhostImage(compCtx, 0, 0, composite.width, composite.height);
      compCtx.restore();
    }
  }

  // Throttle segmentation: var (SEG_EVERY_N+1):e frame, med l√•s
  if (segReady && seg && SEG_ENABLED) {
    try {
      composite.__segCounter = (composite.__segCounter || 0) + 1;
      if (!segBusy && composite.__segCounter % (SEG_EVERY_N + 1) === 0) {
        segBusy = true;
        seg.send({ image: video }).catch(e=>{
          console.warn('[MoodCam] Segmentation send() fel ‚Äì st√§nger av mask:', e);
          SEG_ENABLED = false; segReady = false; seg = null; /* beh√•ll latestMask */
          segBusy = false;
        });
      }
    } catch (e) {
      console.warn('[MoodCam] Segmentation fel ‚Äì st√§nger av mask:', e);
      SEG_ENABLED = false; segReady = false; seg = null; /* beh√•ll latestMask */
      segBusy = false;
    }
  }
}
function startGhostLoop(){
  function step(){
    const now = performance.now();
    maybeTriggerGhost(now);
    compositeFrame();
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

/* ---------- +1-animationer ---------- */
const plusOnes = [];
const PLUS_LIFE = 1.0;

function spawnPlusOne(x, y){
  const ang = Math.random()*Math.PI*2;
  const speed = 40 + Math.random()*100;
  plusOnes.push({ x, y, vx: Math.cos(ang)*speed, vy: Math.sin(ang)*speed, age: 0 });
}

function updateAndDrawPlusOnes(dt){
  for (let i=plusOnes.length-1;i>=0;i--){
    const p = plusOnes[i];
    p.age += dt;
    if (p.age >= PLUS_LIFE){ plusOnes.splice(i,1); continue; }
    p.x += p.vx * dt;
    p.y += p.vy * dt;

    const t = Math.max(0, Math.min(1, p.age/PLUS_LIFE));
    const grow = (t<0.25) ? (t/0.25) : 1;
    const fade = (t<0.7) ? (t/0.7) : (1 - (t-0.7)/0.3);
    const scale = 0.2 + 0.8*grow;

    ctx.save();
    ctx.globalAlpha = Math.max(0, Math.min(1, fade));

    const size = Math.round(28 * scale);
    ctx.font = `bold ${size}px system-ui, "Apple Color Emoji", "Segoe UI Emoji", sans-serif`;
    ctx.textBaseline = 'middle';

    const txt1 = '+1';
    const txt2 = '‚ù§Ô∏è';
    const w1 = ctx.measureText(txt1).width;
    const w2 = ctx.measureText(txt2).width;
    const gap = Math.round(size * 0.25);
    const total = w1 + gap + w2;

    const startX = p.x - total / 2;
    const y = p.y;

    ctx.textAlign = 'left';
    ctx.fillStyle = '#ffffff';
    ctx.fillText(txt1, startX, y);
    const heartX = startX + w1 + gap;
    ctx.fillText(txt2, heartX, y);

    ctx.restore();
  }
}

/* ---------- Huvudloop (detektering/overlay) ---------- */
async function tick(){
  try{
    tf.engine().startScope();

    scheduleResetIfNeeded();
    FRAME_I++;

    if (FRAME_SKIP_N > 0 && (FRAME_I % (FRAME_SKIP_N + 1) === 0)) {
      tf.engine().endScope();
      return requestAnimationFrame(tick);
    }

    const now = performance.now();
    const dt = Math.min(0.1, (now - lastFrameTime)/1000); lastFrameTime = now;

    // FPS-EMA
    const fpsNow = dt > 0 ? 1/dt : 60;
    fpsEMA = fpsEMA + (fpsNow - fpsEMA) * FPS_EMA_A;

    // üõ°Ô∏è H√•ll segmentation p√• n√§r ghost-l√§get √§r aktivt/spelar
    const protectSeg = ghostEnabled || playingGhost;
    if (!protectSeg && fpsEMA < LOW_FPS_OFF && SEG_ENABLED) {
      SEG_ENABLED = false;
      tag('Perf','SEG disabled (low FPS)', fpsEMA.toFixed(1));
    }
    if ((protectSeg || fpsEMA > HIGH_FPS_ON) && !SEG_ENABLED && (localStorage.getItem(PERF_KEY) !== 'light')) {
      SEG_ENABLED = true;
      tag('Perf','SEG enabled (FPS recovered)', fpsEMA.toFixed(1));
    }

    if (FRAME_OPTS.ADAPTIVE_INPUT && (window.__lastFaceCount||0) >= FRAME_OPTS.MANY_FACES_THRESHOLD && DETECTOR_SIZE > FRAME_OPTS.LOW_INPUT_SIZE) {
      DETECTOR_SIZE = FRAME_OPTS.LOW_INPUT_SIZE;
      const isel = document.getElementById('inputSize'); if (isel) isel.value = DETECTOR_SIZE;
    }

    const options = new faceapi.TinyFaceDetectorOptions({ inputSize: DETECTOR_SIZE, scoreThreshold: DETECTOR_SCORE });
    let builder = faceapi.detectAllFaces(video, options);
    if (USE_LANDMARKS && LANDMARKS_AVAILABLE && typeof builder.withFaceLandmarks === 'function') {
      builder = builder.withFaceLandmarks();
    }
    builder = builder.withFaceExpressions().withAgeAndGender();

    const detsFull = await builder;

    const dets = detsFull
      .slice()
      .sort((a,b)=> (b.detection.box.width*b.detection.box.height) - (a.detection.box.width*a.detection.box.height))
      .slice(0, MAX_FACES);
    window.__lastFaceCount = dets.length;

    let frameHappyAdd = 0;

    ctx.clearRect(0,0,overlay.width,overlay.height);

    for (const det of dets){
      const b = det.detection.box; const bbox=[b.x,b.y,b.width,b.height];

      // matchning
      let best=null, bestIoU=0;
      for(const t of tracks){ const i=iou(t.bbox,bbox); if(i>bestIoU){bestIoU=i; best=t;} }
      if(best && bestIoU>0.3){
        const pb=best.bbox;
        best.bbox = pb
          ? [ema(pb[0], bbox[0], BBOX_POS_ALPHA),
             ema(pb[1], bbox[1], BBOX_POS_ALPHA),
             ema(pb[2], bbox[2], BBOX_SIZE_ALPHA),
             ema(pb[3], bbox[3], BBOX_SIZE_ALPHA)]
          : bbox.slice();
        best.last=now;
      } else {
        const t={ id:nextId++, bbox:bbox.slice(), last:now, created:now, seenFrames:0, counted:false,
                  peppText:null, ageHist:[], warm:0, contributing:false, effects:null, pose:{},
                  usePose:false, poseValid:0, poseInvalid:0, emo:'neutral', emoConf:0, lastAge:null,
                  contribAcc:0
                };
        tracks.push(t); if(overlaysEnabled) assignEffects(t);
        best = t;
      }
      const tr=best;

      // Pose
      if (USE_LANDMARKS && det.landmarks){
        const lm = det.landmarks;
        const mean = pts => { const n=pts.length; const s=pts.reduce((a,p)=>({x:a.x+p.x,y:a.y+p.y}),{x:0,y:0}); return {x:s.x/n,y:s.y/n}; };
        const dist = (a,b)=> Math.hypot(a.x-b.x,a.y-b.y);
        const mid  = (a,b)=> ({x:(a.x+b.x)/2, y:(a.y+b.y)/2});
        const Leye = mean(lm.getLeftEye());
        const Reye = mean(lm.getRightEye());
        const eyeC = mid(Leye, Reye);
        const eyeD = dist(Leye, Reye);
        const angle= Math.atan2(Reye.y - Leye.y, Reye.x - Leye.x);
        const mouth = lm.getMouth?.();
        const mL = mouth ? mouth[0] : null;
        const mR = mouth ? mouth[6] : null;
        const mouthC = (mL && mR) ? mid(mL, mR) : null;
        const mouthW = (mL && mR) ? dist(mL, mR) : null;
        const jaw = lm.getJawOutline?.();
        const faceW = jaw ? dist(jaw[0], jaw[16]) : null;
        const pz = tr.pose;
        pz.eyeCx   = ema(pz.eyeCx,   eyeC.x, POSE_ALPHA);
        pz.eyeCy   = ema(pz.eyeCy,   eyeC.y, POSE_ALPHA);
        pz.eyeD    = ema(pz.eyeD,    eyeD,   POSE_ALPHA);
        pz.angle   = ema(pz.angle,   angle,  POSE_ALPHA);
        if (mouthC){ pz.mouthCx = ema(pz.mouthCx, mouthC.x, POSE_ALPHA); pz.mouthCy = ema(pz.mouthCy, mouthC.y, POSE_ALPHA); }
        if (mouthW!=null) pz.mouthW = ema(pz.mouthW, mouthW, POSE_ALPHA);
        if (faceW!=null)  pz.faceW  = ema(pz.faceW,  faceW,  POSE_ALPHA);

        const validNow = isValidPose(tr.pose, {x:b.x, y:b.y, width:b.width, height:b.height});
        if (validNow) { tr.poseValid++; tr.poseInvalid=0; if(!tr.usePose && tr.poseValid>=2) tr.usePose=true; }
        else          { tr.poseInvalid++; tr.poseValid=0; if(tr.usePose && tr.poseInvalid>=6) tr.usePose=false; }
      }

      // Emotion & √•lder
      if (det.expressions){
        const exp=det.expressions||{}; let emo=null, conf=0; for(const [k,v] of Object.entries(exp)) if(v>conf){ emo=k; conf=v; }
        tr.emo = emo; tr.emoConf = conf;
      }
      const latestAge = ('age' in det) ? (det.age ?? null) : null;
      if (latestAge != null) tr.lastAge = latestAge;
      const shownAge = getSmoothedAge(tr, now, latestAge);

      // Glad-bidrag
      if (tr.emo === 'happy' && (tr.emoConf ?? 0) >= EMO_CONF_MIN) {
        const prevWarm = tr.warm || 0;
        tr.warm = Math.min(HAPPY_WARMUP_SECONDS, prevWarm + dt);

        if (prevWarm < HAPPY_WARMUP_SECONDS && tr.warm >= HAPPY_WARMUP_SECONDS) {
          const [bx,by,bw,bh]=tr.bbox;
          const rx = mirrorX(bx, bw);
          spawnPlusOne(rx + bw*0.5, by - 6);
        }

        if (tr.warm >= HAPPY_WARMUP_SECONDS) {
          if (!tr.counted) {
            const key=todayKey();
            visitorsByDay[key]=(visitorsByDay[key]||0)+1;
            localStorage.setItem('moodcam.visitors', JSON.stringify(visitorsByDay));
            updateLogInfo();
            tr.counted = true;
          }
          tr.contributing = true;
          const weight = CONTRIB_WEIGHT_BY_CONF ? tr.emoConf : 1;
          frameHappyAdd += dt * weight;

          tr.contribAcc += dt * weight;
          while (tr.contribAcc >= 1){
            const [bx,by,bw,bh]=tr.bbox;
            const rx = mirrorX(bx, bw);
            spawnPlusOne(rx + bw*0.5, by - 6);
            tr.contribAcc -= 1;
          }
        }
      } else {
        tr.warm = Math.max(0, (tr.warm || 0) - dt * 0.5);
        tr.contributing = false;
        tr.contribAcc = 0;
      }

      // Rita overlay
      const [bx,by,bw,bh]=tr.bbox;
      const rx = mirrorX(bx, bw);
      const color=EMO_COLOR[tr.emo]||'#24ff78';

      drawEffects(tr, bx,by,bw,bh);

      if (SHOW_FACE_BOX) { ctx.strokeStyle=color; ctx.lineWidth=UI.faceBoxWidth; ctx.strokeRect(rx,by,bw,bh); }
      if(tr.emo && (tr.emoConf ?? 0) >= EMO_CONF_MIN){
        const label=`${EMO_SV[tr.emo]||tr.emo} ¬∑ ${Math.round(tr.emoConf*100)}%` + (shownAge!=null?` ¬∑ ${shownAge} √•r`:``);
        drawLabel(rx,by,label);
      } else if(shownAge!=null){ drawLabel(rx,by,`${shownAge} √•r`); }

      const emoji=EMO_EMOJI[tr.emo]||"üôÇ"; const emSize=Math.max(28, Math.round(Math.min(bw,bh)*0.22));
      ctx.font=`${emSize}px serif`; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(emoji, rx + bw, by);

      if (peppEnabled){
        if(!tr.peppText) tr.peppText = randomPepp();
        drawCenteredBottom(rx,by,bw,bh,tr.peppText);
      }
    }

    // gladtid + m√§tare (global)
    HAPPY_PERSON_SECONDS += frameHappyAdd;
    const targetPct = Math.min(100, 100*(HAPPY_PERSON_SECONDS/METER_GOAL_SECONDS));
    meterShown = meterShown + (targetPct - meterShown) * METER_EASE;
    document.getElementById('meterFill').style.width = Math.max(0,Math.min(100,meterShown)) + '%';
    document.getElementById('meterVal').textContent = Math.round(meterShown);

    // ‚úÖ Hj√§rt-/+1-animationer (tillbaka)
    updateAndDrawPlusOnes(dt);

    // st√§da sp√•r
    const tnow=performance.now(); for(let i=tracks.length-1;i>=0;i--) if(tnow-tracks[i].last>1500) tracks.splice(i,1);

  } catch(err){
    console.error('[MoodCam] tick() error:', err);
  } finally {
    tf.engine().endScope();
    requestAnimationFrame(tick);
  }
}

/* ---------- Logg / CSV ---------- */
function updateLogInfo(){ const list=Object.entries(visitorsByDay).sort(([a],[b])=>a.localeCompare(b)); const txt=list.length? list.map(([d,n])=>`${d}: ${n}`).join(' ¬∑ ') : 'Ingen logg √§n.'; const el=document.getElementById('logInfo'); if(el) el.textContent=txt; }
function downloadCSV(){ const rows=[["date","visitors"],...Object.entries(visitorsByDay)]; const csv=rows.map(r=>r.join(',')).join('\n'); const blob=new Blob([csv],{type:'text/csv'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='moodcam_visitors.csv'; a.click(); URL.revokeObjectURL(a.href); }

/* ---------- Presets & backend ---------- */
const PERF_KEY = 'moodcam.perfMode';

async function ensureBackendForMode(_mode){
  try{
    if (tf.getBackend() !== 'webgl') {
      await tf.setBackend('webgl');
      await tf.ready();
      console.info('[MoodCam] TF backend -> WebGL (all modes)');
    }
  } catch(e){
    console.warn('[MoodCam] Kunde inte v√§lja WebGL, k√∂r vidare p√•', tf.getBackend(), e);
  }
}

function applyPreset(mode){
  // Standard
  let cfg = {
    EMO_CONF_MIN: 0.40,
    DETECTOR_SIZE: 320,
    DETECTOR_SCORE: 0.60,
    MAX_FACES: 4,
    FRAME_SKIP_N: 0,
    USE_LANDMARKS: true,
    SEG_EVERY_N: 1,
    SEG_ENABLED: true
  };

  if (mode === 'light'){
    cfg = {
      EMO_CONF_MIN: 0.40,
      DETECTOR_SIZE: 224,
      DETECTOR_SCORE: 0.65,
      MAX_FACES: 1,
      FRAME_SKIP_N: 2,
      USE_LANDMARKS: false,
      SEG_EVERY_N: 999,
      SEG_ENABLED: false
    };
  }

  EMO_CONF_MIN  = cfg.EMO_CONF_MIN;
  DETECTOR_SIZE = cfg.DETECTOR_SIZE;
  DETECTOR_SCORE= cfg.DETECTOR_SCORE;
  MAX_FACES     = cfg.MAX_FACES;
  FRAME_SKIP_N  = cfg.FRAME_SKIP_N;
  USE_LANDMARKS = cfg.USE_LANDMARKS;
  SEG_EVERY_N   = cfg.SEG_EVERY_N;
  SEG_ENABLED   = cfg.SEG_ENABLED;

  const confEl = document.getElementById('conf');
  const sizeEl = document.getElementById('inputSize');
  const scoreEl= document.getElementById('score');
  if (confEl)  confEl.value  = EMO_CONF_MIN.toFixed(2);
  if (sizeEl)  sizeEl.value  = String(DETECTOR_SIZE);
  if (scoreEl) scoreEl.value = DETECTOR_SCORE.toFixed(2);

  localStorage.setItem(PERF_KEY, mode);
  tag('Perf','applyPreset',mode,{EMO_CONF_MIN,DETECTOR_SIZE,DETECTOR_SCORE,MAX_FACES,FRAME_SKIP_N,USE_LANDMARKS,SEG_EVERY_N,SEG_ENABLED});
}

/* ---------- OM/README + Version ---------- */
function escapeHtml(s){
  return s.replace(/[&<>"']/g, c => ({
    '&':'&amp;',
    '<':'&lt;',
    '>':'&gt;',
    '"':'&quot;',
    "'":'&#39;'
  }[c]));
}

function mdToHtml(md){
  const blocks = [];
  md = md.replace(/```([\s\S]*?)```/g, (_, code) => {
    blocks.push(code); return `¬ß¬ß¬ßBLOCK${blocks.length-1}¬ß¬ß¬ß`;
  });
  md = md.replace(/^### (.*)$/gm, '<h3>$1</h3>')
         .replace(/^## (.*)$/gm, '<h2>$1</h2>')
         .replace(/^# (.*)$/gm, '<h1>$1</h1>');
  md = md.replace(/^(?:-|\*) (.*)$/gm, '<li>$1</li>');
  md = md.replace(/(<li>[\s\S]*?<\/li>)/g, '<ul>$1</ul>');
  md = md.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
         .replace(/\*(.+?)\*/g, '<em>$1</em>');
  md = md.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');
  md = md.replace(/`([^`]+)`/g, '<code>$1</code>');
  md = md.split(/\n{2,}/).map(chunk=>{
    if (/^<h\d|^<ul>|^<li>|^¬ß¬ß¬ßBLOCK/.test(chunk.trim())) return chunk;
    return `<p>${chunk.replace(/\n/g,'<br>')}</p>`;
  }).join('\n');
  md = md.replace(/¬ß¬ß¬ßBLOCK(\d+)¬ß¬ß¬ß/g, (_, i)=> `<pre><code>${escapeHtml(blocks[+i])}</code></pre>`);
  return md;
}

let __aboutLoaded = false;
async function loadAboutOnce(){
  if (__aboutLoaded) return;
  try{
    const r = await fetch('./README.md', { cache:'no-store' });
    const txt = await r.text();
    document.getElementById('aboutBody').innerHTML = mdToHtml(txt);
    __aboutLoaded = true;
  }catch(e){
    document.getElementById('aboutBody').textContent = 'Kunde inte l√§sa README.md';
    console.error('[OM] fetch README.md fel:', e);
  }
}

function toggle(el){ el.style.display = (el.style.display==='none'||!el.style.display) ? 'block' : 'none'; }

function showVersionInSettings(){
  const t = document.title || '';
  const m = t.match(/\(v\.([^)]+)\)/i);
  const v = m ? m[1] : 'ok√§nd';
  const el = document.getElementById('verInfo');
  if (el) el.textContent = `Version: v.${v}`;
}

/* ---------- MediaPipe Selfie Segmentation ---------- */
async function setupSegmentation(){
  try{
    seg = new SelfieSegmentation({ locateFile: (file) => `./vendor/mediapipe/selfie_segmentation/${file}` });
    seg.setOptions({ modelSelection: 1 });
    seg.onResults((res)=>{
      try{
        const c = document.createElement('canvas');
        c.width = res.segmentationMask.width;
        c.height = res.segmentationMask.height;
        const cctx = c.getContext('2d');
        cctx.drawImage(res.segmentationMask, 0, 0);
        latestMask = c;
        segReady = true; /* ‚úÖ redo f√∂rst n√§r vi har f√∂rsta masken */
      }catch(e){
        console.warn('[Seg] onResults fel:', e);
      } finally {
        segBusy = false;
      }
    });
    // ‚õîÔ∏è segReady s√§tts inte h√§r ‚Äì v√§ntar p√• f√∂rsta mask
    tag('Seg','init ok');
  }catch(e){
    segReady = false;
    console.warn('[Seg] kunde inte initiera:', e);
  }
}

/* ---------- L√§s ghost-lista ---------- */
async function loadGhostClips(){
  try{
    const res = await fetch('./ghosts/manifest.json', { cache: 'no-store' });
    if (!res.ok) return;
    const arr = await res.json();
    const mp4 = (Array.isArray(arr) ? arr : [])
      .filter(x => typeof x === 'string' && /\.mp4$/i.test(x))
      .map(x => (x.startsWith('ghosts/') ? x : ('ghosts/' + x.replace(/^\.?\//, '')))); // ‚úÖ tre avslutande paranteser
    if (mp4.length) {
      GHOST_CLIPS = Array.from(new Set(mp4));
      tag('Ghost','manifest.json', GHOST_CLIPS);
    }
  }catch(_e){ /* tyst fallback */ }
}
/* ---------- Init ---------- */
async function init(){
  console.info('[MoodCam] Init‚Ä¶ TFJS:', (tf && tf.version_core)||'n/a', 'face-api:', (faceapi && faceapi.version)||'n/a');

  try { await tf.setBackend('webgl'); await tf.ready(); console.info('[MoodCam] TF backend:', tf.getBackend()); }
  catch(e) {
    console.warn('[MoodCam] WebGL misslyckades, provar WASM:', e);
    try { await tf.setBackend('wasm'); await tf.ready(); console.info('[MoodCam] TF backend:', tf.getBackend()); }
    catch(e2){ console.warn('[MoodCam] WASM misslyckades ocks√•:', e2); }
  }

  const wrap=document.getElementById('wrap');
  video=document.getElementById('video');
  overlay=document.getElementById('overlay'); ctx=overlay.getContext('2d');
  composite=document.getElementById('composite'); compCtx=composite.getContext('2d', { willReadFrequently:true });
  ghostEl=document.getElementById('ghost');

  ghostEl.muted = true;
  ghostEl.playsInline = true;
  ghostEl.preload = 'auto';

  const mirrorBox = document.getElementById('mirrorX');
  MIRROR = !!mirrorBox.checked;
  wrap.classList.toggle('mirror', MIRROR);

  // Panel-handlers
  document.getElementById('settingsBtn').addEventListener('click', ()=>{
    const s=document.getElementById('settings');
    toggle(s);
    document.getElementById('about').style.display='none';
  });
  document.getElementById('aboutBtn').addEventListener('click', async ()=>{
    const a=document.getElementById('about');
    document.getElementById('settings').style.display='none';
    await loadAboutOnce();
    toggle(a);
  });

  showVersionInSettings();

  // UI handlers
  document.getElementById('conf').addEventListener('input', e=> EMO_CONF_MIN=parseFloat(e.target.value));
  document.getElementById('inputSize').addEventListener('input', e=> DETECTOR_SIZE=parseInt(e.target.value,10));
  document.getElementById('score').addEventListener('input', e=> DETECTOR_SCORE=parseFloat(e.target.value));
  document.getElementById('peppToggle').addEventListener('change', e=> { peppEnabled=e.target.checked; });
  document.getElementById('peppCat').addEventListener('change', e=> { peppCat=e.target.value; });

  ['fBrightness','fContrast','fSaturate','fHue','fTemp'].forEach(id=>{
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener('input', ()=>{
      CAM_FILTER = buildCamFilterString();
      // ‚ùå Inget filter p√• <video>; vi ritar filtret i canvas
    });
  });

  const resetBtn = document.getElementById('filtersReset');
  if (resetBtn) resetBtn.addEventListener('click', ()=>{
    const b = document.getElementById('fBrightness');
    const c = document.getElementById('fContrast');
    const s = document.getElementById('fSaturate');
    const h = document.getElementById('fHue');
    const t = document.getElementById('fTemp');
    if (b) b.value = 100;
    if (c) c.value = 100;
    if (s) s.value = 100;
    if (h) h.value =   0;
    if (t) t.value =   0;
    CAM_FILTER = buildCamFilterString();
    // ‚ùå Inget filter p√• <video>
  });

  CAM_FILTER = buildCamFilterString();
  // ‚ùå video.style.filter = CAM_FILTER;  (borttagen)

  document.getElementById('mirrorX').addEventListener('change', e=>{
    MIRROR = e.target.checked; wrap.classList.toggle('mirror', MIRROR);
  });

  const showBoxEl = document.getElementById('showBox');
  showBoxEl.checked = SHOW_FACE_BOX;
  showBoxEl.addEventListener('change', e=>{ SHOW_FACE_BOX = e.target.checked; });

  const themeSel = document.getElementById('themeSel');
  THEMES.forEach(t=>{ const o=document.createElement('option'); o.value=t; o.textContent=t; themeSel.appendChild(o); });
  themeSel.value = selectedTheme;
  themeSel.addEventListener('change', async e=>{
    selectedTheme = e.target.value;
    if (overlaysEnabled) { await loadOverlayManifest(selectedTheme); tracks.forEach(t=>assignEffects(t)); }
  });

  // Overlays startl√§ge
  const overlayToggleEl = document.getElementById('overlayToggle');
  const ovHatsEl = document.getElementById('ovHats');
  const ovGlassesEl = document.getElementById('ovGlasses');
  const ovEyesEl = document.getElementById('ovEyes');
  const ovMouthEl = document.getElementById('ovMouth');
  const ovBeardEl = document.getElementById('ovBeard');

  overlaysEnabled = overlayToggleEl.checked; // false
  overlayUse.hats   = ovHatsEl.checked;
  overlayUse.glasses= ovGlassesEl.checked;
  overlayUse.eyes   = ovEyesEl.checked;
  overlayUse.mouth  = ovMouthEl.checked;
  overlayUse.beard  = ovBeardEl.checked;

  overlayToggleEl.addEventListener('change', async e=> {
    overlaysEnabled=e.target.checked;
    if (overlaysEnabled && !overlayManifest) await loadOverlayManifest(selectedTheme);
    tracks.forEach(t=>assignEffects(t));
  });
  ovHatsEl.addEventListener('change', e=> { overlayUse.hats=e.target.checked; tracks.forEach(t=>assignEffects(t)); });
  ovGlassesEl.addEventListener('change', e=> { overlayUse.glasses=e.target.checked; tracks.forEach(t=>assignEffects(t)); });
  ovEyesEl.addEventListener('change', e=> { overlayUse.eyes=e.target.checked; tracks.forEach(t=>assignEffects(t)); });
  ovMouthEl.addEventListener('change', e=> { overlayUse.mouth=e.target.checked; tracks.forEach(t=>assignEffects(t)); });
  ovBeardEl.addEventListener('change', e=> { overlayUse.beard=e.target.checked; tracks.forEach(t=>assignEffects(t)); });

  document.getElementById('dlLog').addEventListener('click', downloadCSV);
  document.getElementById('clearLog').addEventListener('click', ()=> { localStorage.setItem('moodcam.visitors','{}'); for (const k in visitorsByDay) delete visitorsByDay[k]; updateLogInfo(); });

  const goalInput=document.getElementById('goalSec'); const goalLabel=document.getElementById('goalLabel');
  METER_GOAL_SECONDS=parseInt(goalInput.value,10); goalLabel.textContent=METER_GOAL_SECONDS;
  goalInput.addEventListener('input', e=>{ METER_GOAL_SECONDS=parseInt(e.target.value,10); goalLabel.textContent=METER_GOAL_SECONDS; });

  // Sp√∂k-settings
  const ghostToggle = document.getElementById('ghostToggle');
  const ghostModeSel = document.getElementById('ghostMode');
  const ghostFacesOnlyEl = document.getElementById('ghostFacesOnly');
  const ghostBgAlphaEl = document.getElementById('ghostBgAlpha');
  const ghostMirrorEl = document.getElementById('ghostMirrorX');
  const ghostAlphaEl  = document.getElementById('ghostAlpha');
  const ghostFadeEl   = document.getElementById('ghostFade');

  ghostEl.addEventListener('loadeddata', ()=> tag('Ghost','loadeddata', ghostEl.videoWidth, ghostEl.videoHeight));
  ghostEl.addEventListener('play', ()=> tag('Ghost','play'));
  ghostEl.addEventListener('pause', ()=> tag('Ghost','pause'));
  ghostEl.addEventListener('error', ()=> console.error('[Ghost] video error', ghostEl.error));
  document.getElementById('ghostNow').addEventListener('click', ()=> { tag('Ghost','knapp: spela nu (FORCE)'); playGhostOnce(true); });

  // ‚õîÔ∏è Startl√§ge: av
  ghostEnabled = ghostToggle.checked;
  ghostMode = ghostModeSel.value; ghostAvgSec = modeToAvgSec(ghostMode);
  ghostFacesOnly = ghostFacesOnlyEl.checked;
  ghostBgAlpha = parseInt(ghostBgAlphaEl.value,10)/100;
  ghostMirror = !!ghostMirrorEl.checked;
  ghostTransparencyPct = parseInt(ghostAlphaEl.value,10) || 0;
  ghostOpacity = Math.max(0, Math.min(1, 1 - (ghostTransparencyPct/100)));
  ghostFadeEnabled = !!ghostFadeEl.checked;

  ghostToggle.addEventListener('change', e=>{ ghostEnabled = e.target.checked; tag('Ghost','enabled=', ghostEnabled); });
  ghostModeSel.addEventListener('change', e=>{ ghostMode = e.target.value; ghostAvgSec = modeToAvgSec(ghostMode); tag('Ghost','mode=',ghostMode,'avgSec=',ghostAvgSec); });
  ghostFacesOnlyEl.addEventListener('change', e=>{ ghostFacesOnly = e.target.checked; tag('Ghost','facesOnly=',ghostFacesOnly); });
  ghostBgAlphaEl.addEventListener('input', e=>{ ghostBgAlpha = parseInt(e.target.value,10)/100; tag('Ghost','bgAlpha=',ghostBgAlpha); });
  ghostMirrorEl.addEventListener('change', e=>{ ghostMirror = e.target.checked; tag('Ghost','mirror=',ghostMirror); });
  ghostAlphaEl.addEventListener('input',  e=>{
    ghostTransparencyPct = parseInt(e.target.value,10) || 0;
    ghostOpacity = Math.max(0, Math.min(1, 1 - (ghostTransparencyPct/100)));
    tag('Ghost','transparency%=',ghostTransparencyPct,'opacity=',ghostOpacity.toFixed(2));
  });
  ghostFadeEl.addEventListener('change', e=>{
    ghostFadeEnabled = e.target.checked;
    tag('Ghost','fadeEnabled=',ghostFadeEnabled);
    if (!ghostFadeEnabled) ghostFade = playingGhost ? 1 : 0;
  });

  await loadAssetMeta();
  await loadPepp();
  listCams(1);
  ensureModelsLoading();
  await setupSegmentation();
  await loadGhostClips();

  // üîß Ladda preset, l√•s WebGL och koppla UI
  const perfSel = document.getElementById('perfMode');
  const savedMode = localStorage.getItem(PERF_KEY) || 'standard';
  perfSel.value = savedMode;
  await ensureBackendForMode(savedMode);
  applyPreset(savedMode);
  perfSel.addEventListener('change', async (e)=>{
    const m = e.target.value;
    await ensureBackendForMode(m);
    applyPreset(m);
  });

  /* ‚å®Ô∏è HEMLIG TANGENT: G = spela sp√∂ke direkt (force) */
  document.addEventListener('keydown', (e)=>{
    if (e.repeat) return;
    const active = document.activeElement;
    const typing = active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable);
    if (typing) return;

    const key = e.key || '';
    if ((key === 'g' || key === 'G')) {
      e.preventDefault();
      tag('Ghost','KB-trigger (G) ‚Äì FORCE');
      playGhostOnce(true);
    }
    if (key === 'Escape'){
      document.getElementById('settings').style.display = 'none';
      document.getElementById('about').style.display = 'none';
    }
  });

  document.getElementById('start').addEventListener('click', async ()=>{
    const modelsOK = await ensureModelsLoading(); if (!modelsOK) return;
    const sel=document.getElementById('camSel');
    const ok = await startCamera(sel.value); if (!ok) return;

    new ResizeObserver(()=>{ syncOverlaySize(); }).observe(document.getElementById('wrap'));

    console.info('[MoodCam] Kamera ig√•ng, startar loop‚Ä¶');
    requestAnimationFrame(tick);
    startGhostLoop();
    tag('Init','kamera ig√•ng, loopar. video=', video.videoWidth, video.videoHeight);
    document.getElementById('start').disabled = true;
  });

  window.addEventListener('error', (e)=> console.error('[MoodCam] window error:', (e && (e.error||e.message)) || e));
}
window.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
