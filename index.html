<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Vialundskolans MoodCam (v.1.3.1)</title>
  <link rel="icon" href="data:,">
<style>
  :root{--bg:#0b0f14;--fg:#e7effa;--panel:#0f172a;--panel2:#111827;--border:#1f2937;--accent:#22c55e}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,sans-serif}
  #stage{display:grid;grid-template-columns:1fr;gap:16px;height:100vh;align-items:center;justify-items:center;padding:12px}

  .topbar{position:fixed;top:10px;left:10px;display:flex;gap:8px;z-index:10}
  .btn{background:var(--panel2);border:1px solid var(--border);color:var(--fg);padding:8px 12px;border-radius:8px;cursor:pointer}
  .btn:disabled{opacity:.5;cursor:not-allowed}

  .layer-wrap{position:relative;display:inline-block;border-radius:12px;overflow:hidden;box-shadow:0 12px 36px rgba(0,0,0,.5);max-width:96vw;max-height:86vh}

  /* Spegelv√§ndning: endast videon, INTE canvas (s√• texten f√∂rblir l√§sbar) */
  .layer-wrap.mirror video { transform: scaleX(-1); }

  /* Ordning: video (0) < canvas (1) < meter (2) */
  video{ display:block;width:100%;height:auto; position:relative; z-index:0; }
  canvas{ position:absolute; inset:0; width:100%; height:100%; pointer-events:none; z-index:1; }
  #meterWrap{
    position:absolute; left:50%; transform:translateX(-50%); bottom:0;
    background:var(--panel); border:1px solid var(--border);
    border-bottom-left-radius:0; border-bottom-right-radius:0;
    border-top-left-radius:10px; border-top-right-radius:10px;
    padding:6px 10px; width:min(360px,70%); z-index:2;
  }

  #meterBar{position:relative;height:8px;background:#0d1218;border-radius:6px;overflow:hidden;border:1px solid var(--border)}
  #meterFill{height:100%;width:0%;background:linear-gradient(90deg,#2dd4bf,#22c55e)}
  .meterVal{position:absolute;right:6px;top:-16px;opacity:.85}
  .small{font-size:12px;opacity:.8}

  #settings{display:none;position:fixed;right:12px;top:52px;width:360px;max-height:85vh;overflow:auto;background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:12px 12px 8px;z-index:20}
  #settings h3{margin:6px 0 8px 0;font-size:16px}
  #settings .row{display:flex;justify-content:space-between;align-items:center;margin:8px 0}
  #settings label{font-size:14px}

  details{border:1px dashed var(--border);border-radius:8px;padding:6px;margin-top:8px}
  summary{cursor:pointer}
  .desc{font-size:12px;opacity:.75;margin:4px 0 0}
  input[type="range"]{width:190px}
  .two-col{display:grid;grid-template-columns:auto 1fr;gap:8px;align-items:center}
  .hud{position:fixed;left:14px;bottom:14px;font-size:12px;opacity:.7}
</style>
  <!-- Libs -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.21.0/dist/tf.min.js"></script>
  <!-- WASM fallback (anv√§nds om WebGL ej fungerar) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@4.21.0/dist/tf-backend-wasm.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api/dist/face-api.min.js"></script>
</head>
<body>
  <div class="topbar">
    <button id="start" class="btn">Starta kamera</button>
    <button id="settingsBtn" class="btn">Settings</button>
  </div>

  <div id="stage">
    <div class="layer-wrap" id="wrap">
      <video id="video" autoplay muted playsinline></video>
      <canvas id="overlay"></canvas>

      <div id="meterWrap">
        <div id="meterBar">
          <div id="meterFill"></div>
          <span id="meterVal" class="small meterVal">0</span>
        </div>
        <div class="small" style="margin-top:2px">
          Moodm√§tare ‚Äì B√∂rjar √∂ka efter <em>3s</em>, s√• SMILE üòÑ
        </div>
      </div>
    </div>
  </div>

  <div id="settings">
    <h3>Settings</h3>
    <div class="row">
      <label for="camSel">Kamera</label>
      <select id="camSel" class="btn" style="width:220px"></select>
    </div>
    <div class="row">
      <label for="conf">Konfidens (etikett)</label>
      <input id="conf" type="range" min="0.2" max="0.9" step="0.05" value="0.40">
    </div>
    <div class="row">
      <label for="inputSize">Detector size</label>
      <input id="inputSize" type="range" min="224" max="512" step="32" value="320">
    </div>

    <details open>
      <summary>Peppande one-liners</summary>
      <div class="row" style="margin-top:8px">
        <label>Aktivera</label><input type="checkbox" id="peppToggle" checked>
      </div>
      <div class="row">
        <label for="peppCat">Kategori</label>
        <select id="peppCat" class="btn" style="width:220px">
          <!-- Fylls dynamiskt fr√•n pepp.json -->
        </select>
      </div>
      <p class="desc">Visas i varje ansiktsruta, l√•ses per person tills de l√§mnar bild. Kategorier och texter l√§ses fr√•n <code>pepp.json</code>.</p>
    </details>

    <details>
      <summary>Overlays & teman</summary>
      <div class="row">
        <label>Aktivera overlays</label><input type="checkbox" id="overlayToggle">
      </div>
      <div class="row">
        <label for="themeSel">Tema</label>
        <select id="themeSel" class="btn" style="width:220px"></select>
      </div>
      <div class="row"><label>Hattar</label><input type="checkbox" id="ovHats" checked></div>
      <div class="row"><label>Glas√∂gon</label><input type="checkbox" id="ovGlasses" checked></div>
      <div class="row"><label>√ñgon</label><input type="checkbox" id="ovEyes" checked></div>
      <div class="row"><label>Munnar</label><input type="checkbox" id="ovMouth" checked></div>
      <div class="row"><label>Sk√§gg</label><input type="checkbox" id="ovBeard" checked></div>
      <div class="row"><label>Visa ansiktsruta</label><input type="checkbox" id="showBox"></div>
      <p class="desc">Tema anger *vilka filer*; passform kommer fr√•n <code>img/assets/meta.json</code>.</p>
    </details>

    <details>
      <summary>Kamera ‚Äì bild (filter)</summary>
      <div class="two-col">
        <label for="fBrightness">Ljusstyrka</label><input id="fBrightness" type="range" min="50" max="150" step="1" value="100">
        <label for="fContrast">Kontrast</label><input id="fContrast"   type="range" min="50" max="150" step="1" value="100">
        <label for="fSaturate">M√§ttnad</label><input id="fSaturate"    type="range" min="0"  max="200" step="1" value="100">
        <label for="fHue">Ton (¬∞)</label><input id="fHue"              type="range" min="-180" max="180" step="1" value="0">
        <label for="fTemp">Temperatur</label><input id="fTemp"         type="range" min="-50" max="50" step="1" value="0">
        <label for="mirrorX">Spegelv√§nd bild</label><input id="mirrorX" type="checkbox">
      </div>
      <div class="row"><button id="filtersReset" class="btn">√Öterst√§ll</button></div>
      <p class="desc">P√•verkar bara visningen (inte detekteringen).</p>
    </details>

    <details>
      <summary>Bes√∂kslogg</summary>
      <div class="row" style="margin-top:8px">
        <button id="dlLog" class="btn">Ladda ner CSV</button>
        <button id="clearLog" class="btn" style="background:#581c1c;border-color:#7f1d1d">Nollst√§ll</button>
      </div>
      <p id="logInfo" class="small"></p>
    </details>

    <details>
      <summary>Moodm√§tare ‚Äì m√•l</summary>
      <div class="row">
        <label for="goalSec">M√•l (sekunder glad-tid)</label>
        <input id="goalSec" type="range" min="300" max="3600" step="60" value="900">
      </div>
      <p class="small">Nuvarande m√•l: <span id="goalLabel">900</span> s</p>
    </details>
  </div>

  <div class="hud">Allt k√∂rs lokalt i datorn. /Kristoffer</div>

<script>
/* ---------- Konsolfilter ---------- */
const ORIG_CONSOLE = { info: console.info, warn: console.warn, log: console.log };
const NOISE_PATTERNS = [/already been set/i,/backend was already registered/i,/kernel .* already registered/i];
console.warn = (...a)=>{ const s=(a||[]).join(' '); if (NOISE_PATTERNS.some(r=>r.test(s))) return; ORIG_CONSOLE.warn.apply(console,a); };
console.info = (...a)=>{ const s=(a||[]).join(' '); if (NOISE_PATTERNS.some(r=>r.test(s))) return; ORIG_CONSOLE.info.apply(console,a); };

const DEBUG = false;

/* ---------- Konstanter & state ---------- */
const EMO_SV = { angry:"Arg", disgusted:"√Ñcklad", fearful:"R√§dd", happy:"Glad", neutral:"Neutral", sad:"Ledsen", surprised:"F√∂rv√•nad" };
const EMO_EMOJI = { angry:"üò†", disgusted:"ü§¢", fearful:"üò®", happy:"üòÑ", neutral:"üòê", sad:"üò¢", surprised:"üòÆ" };
const EMO_COLOR = { happy:"#28c728", angry:"#2a2ae0", sad:"#c07800", surprised:"#c0c000", fearful:"#00b4b4", disgusted:"#00a078", neutral:"#b0b0b0" };
const UI = { labelFontSize:14, labelPad:4, pepFontSize:14, pepPad:4, faceBoxWidth:2 };

let EMO_CONF_MIN = 0.40;
let DETECTOR_SIZE = 320;

let peppEnabled = true;
let peppCat = 'all';
let PEPP = {};        // l√§ses fr√•n pepp.json
let PEPP_KEYS = [];

const THEMES = ["Aktivt (img/manifest.json)","halloween","jul","sommar","skolstart","test"];
let selectedTheme = THEMES[0];

let overlaysEnabled = false;
const overlayUse = { hats:true, glasses:true, eyes:true, mouth:true, beard:true };
let overlayManifest = null;
const imgCache = new Map();

let assetMeta = {};
async function loadAssetMeta(){
  try{
    const r = await fetch('./img/assets/meta.json', {cache:'no-store'});
    if (r.ok) assetMeta = await r.json();
  }catch(e){ if (DEBUG) console.warn('[MoodCam] assets/meta.json saknas/ol√§slig', e); }
}

let LANDMARKS_AVAILABLE = false;

let video, overlay, ctx, currentStream=null;

/* Tracks */
const tracks = [];
let nextId = 1;

let lastFrameTime = performance.now();

/* Mood-meter */
let HAPPY_PERSON_SECONDS = 0;
let METER_GOAL_SECONDS = 900;
let meterShown = 0;
const METER_EASE = 0.07;
const HAPPY_WARMUP_SECONDS = 3;
const CONTRIB_WEIGHT_BY_CONF = true;

const RESET_H = 19, RESET_M = 30;

/* Jitter-filter */
const POSE_ALPHA = 0.15;
const BBOX_POS_ALPHA  = 0.65; // snabbare position
const BBOX_SIZE_ALPHA = 0.85; // snabbare storlek
const ema = (prev, next, a)=> (prev==null? next : prev + a*(next - prev));

/* Spegeltillst√•nd */
let MIRROR = false;

/* Visa/d√∂lj ansiktsruta ‚Äì default: osynlig */
let SHOW_FACE_BOX = false;

/* Begr√§nsa per frame / adaptiv arbetstakt */
const MAX_FACES = 4;
const FRAME_OPTS = {
  LANDMARK_EVERY: 2,      // uppdatera landmarks var 2:a frame
  ATTR_EVERY: 2,          // expressions var 2:a frame
  AGE_EVERY: 8,           // age/gender var 8:e frame
  DRAW_OVERLAYS_EVERY: 2, // rita overlays var 2:a frame om m√•nga ansikten
  ADAPTIVE_INPUT: false,  // s√§nk inputSize n√§r m√•nga ansikten
  MANY_FACES_THRESHOLD: 3,
  LOW_INPUT_SIZE: 288
};
let FRAME_I = 0;

/* Anti-blink / hysteresis n√§r det inte hittas ansikten */
const EMPTY_HYST_MS = 300;    // beh√•ll senaste ritning i upp till 300 ms
let lastNonEmptyTs = 0;       // senaste ts d√• minst ett ansikte fanns

/* Logg */
const visitorsByDay = JSON.parse(localStorage.getItem('moodcam.visitors') || '{}');
updateLogInfo();
const AGE_SMOOTH_WINDOW_MS = 10_000;

/* ---------- Hj√§lp ---------- */
function todayKey(){ const d=new Date(); return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`; }
function scheduleResetIfNeeded(){ const now=new Date(); const reset=new Date(); reset.setHours(RESET_H, RESET_M, 0, 0); if (Math.abs(now-reset)<1000){ HAPPY_PERSON_SECONDS=0; meterShown=0; } }
function iou(a,b){ const [ax,ay,aw,ah]=a,[bx,by,bw,bh]=b; const x1=Math.max(ax,bx), y1=Math.max(ay,by), x2=Math.min(ax+aw,bx+bw), y2=Math.min(ay+ah,by+bh);
  const inter=Math.max(0,x2-x1)*Math.max(0,y2-y1), union=aw*ah+bw*bh-inter; return union>0? inter/union:0; }

function mirrorX(x, w=0){ return MIRROR ? (overlay.width - (x + w)) : x; }

function drawLabel(x,y,text){
  ctx.font = `${UI.labelFontSize}px system-ui`; ctx.textAlign='left'; ctx.textBaseline='alphabetic';
  const pad=UI.labelPad, h=UI.labelFontSize*1.2, w=ctx.measureText(text).width;
  ctx.fillStyle='rgba(0,0,0,0.85)'; ctx.fillRect(x-pad,y-h-pad,w+pad*2,h+pad*2);
  ctx.fillStyle='#fff'; ctx.fillText(text,x,y);
}
function drawCenteredBottom(x,y,w,h,text){
  if (!text) return;
  ctx.font = `${UI.pepFontSize}px system-ui`; ctx.textAlign='left'; ctx.textBaseline='alphabetic';
  const pad=UI.pepPad, htxt=UI.pepFontSize*1.2, tw=ctx.measureText(text).width, cx=x+w/2-tw/2, cy=y+h-8;
  ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(cx-pad,cy-htxt-pad,tw+pad*2,htxt+pad*2);
  ctx.fillStyle='#fff'; ctx.fillText(text,cx,cy);
}
function syncOverlaySize(){ overlay.width=video.videoWidth; overlay.height=video.videoHeight; overlay.style.width=video.clientWidth+'px'; overlay.style.height=video.clientHeight+'px'; }

function getSmoothedAge(track, now, latestAge){
  if (latestAge!=null && !Number.isNaN(latestAge)) track.ageHist.push({t:now,a:latestAge});
  const cutoff=now-AGE_SMOOTH_WINDOW_MS; while (track.ageHist.length && track.ageHist[0].t<cutoff) track.ageHist.shift();
  if (now-track.created<AGE_SMOOTH_WINDOW_MS) return latestAge!=null?Math.round(latestAge):null;
  if (!track.ageHist.length) return latestAge!=null?Math.round(latestAge):null;
  const avg=track.ageHist.reduce((s,p)=>s+p.a,0)/track.ageHist.length; return Math.round(avg);
}

/* ---------- Pepp (extern) ---------- */
async function loadPepp(){
  try{
    const r = await fetch('./pepp.json', {cache:'no-store'});
    if(!r.ok) throw new Error('Kunde inte l√§sa pepp.json');
    const data = await r.json();
    const ok = Object.fromEntries(
      Object.entries(data)
        .filter(([k,v]) => Array.isArray(v))
        .map(([k,v]) => [k, v.filter(x => typeof x === 'string')])
    );
    PEPP = ok;
    PEPP_KEYS = Object.keys(PEPP);
    populatePeppCategories();
  }catch(e){
    console.error('[MoodCam] pepp.json fel:', e);
    PEPP = {}; PEPP_KEYS = [];
    populatePeppCategories();
  }
}
function populatePeppCategories(){
  const sel = document.getElementById('peppCat');
  sel.innerHTML = '';
  if (PEPP_KEYS.length){
    const oAll=document.createElement('option'); oAll.value='all'; oAll.textContent='Alla'; sel.appendChild(oAll);
  }
  PEPP_KEYS.sort().forEach(k=>{
    const o=document.createElement('option'); o.value=k; o.textContent=k; sel.appendChild(o);
  });
  peppCat = (PEPP_KEYS.length ? 'all' : '');
  sel.value = peppCat || (PEPP_KEYS[0] || '');
}
function randomPepp(){
  if (!peppEnabled || !PEPP_KEYS.length) return '';
  const pool = (peppCat === 'all' || !peppCat)
    ? PEPP_KEYS.flatMap(k => PEPP[k] || [])
    : (PEPP[peppCat] || []);
  if (!pool.length) return '';
  return pool[Math.floor(Math.random()*pool.length)];
}

/* --------- Overlays & teman --------- */
async function loadOverlayManifest(themeName){
  overlayManifest=null;
  let url;
  if (!themeName || themeName === THEMES[0]) url = './img/manifest.json';
  else url = `./img/tema/${themeName}/manifest.json`;
  try{
    const resp=await fetch(url,{cache:'no-store'});
    if(!resp.ok) return;
    const data=await resp.json();
    if (!data.facial_hair && data.faceal_hair) data.facial_hair = data.faceal_hair;
    for (const cat of ["hats","glasses","eyes","mouth","facial_hair"]) {
      const src = data[cat] || [];
      data[cat] = src.map(it => (typeof it === 'string' ? { file: it } : it));
    }
    overlayManifest = data;
    const toLoad=[];
    for (const cat of ["hats","glasses","eyes","mouth","facial_hair"]) {
      (data[cat]||[]).forEach(item=>{
        const path = `./img/${item.file}`;
        if(!imgCache.has(path)){
          const im = new Image();
          im.src = path;
          imgCache.set(path, im); // fallback
          const p = (im.decode?.() ?? new Promise(r=>{im.onload=r;im.onerror=r;}))
            .then(async ()=>{
              if ('createImageBitmap' in window) {
                try {
                  const bm = await createImageBitmap(im);
                  imgCache.set(path, bm); // snabbare ritning
                } catch {}
              }
            });
          toLoad.push(p);
        }
      });
    }
    await Promise.all(toLoad);
  } catch(e){ if (DEBUG) console.warn('[MoodCam] Overlay manifest kunde inte laddas', e); }
}
function choiceWeighted(arr){
  if(!arr || !arr.length) return null;
  const weights = arr.map(o => (o.prob ?? 1));
  const sum = weights.reduce((a,b)=>a+b,0);
  let r = Math.random()*sum;
  for (let i=0;i<arr.length;i++){ r -= weights[i]; if (r <= 0) return arr[i]; }
  return arr[arr.length-1];
}
function assignEffects(track){
  if(!overlaysEnabled || !overlayManifest){ track.effects=null; return; }
  const e={};
  if (overlayUse.hats) e.hat = choiceWeighted(overlayManifest.hats) || null;

  // √ñgon/glas√∂gon exklusivt om b√•da √§r aktiva
  if (overlayUse.eyes && overlayUse.glasses) {
    const pickEyes = Math.random() < 0.5;
    if (pickEyes) e.eyes = choiceWeighted(overlayManifest.eyes) || null;
    else          e.glass = choiceWeighted(overlayManifest.glasses) || null;
  } else {
    if (overlayUse.eyes)    e.eyes  = choiceWeighted(overlayManifest.eyes) || null;
    if (overlayUse.glasses) e.glass = choiceWeighted(overlayManifest.glasses) || null;
  }
  if (overlayUse.mouth) e.mouth = choiceWeighted(overlayManifest.mouth) || null;
  if (overlayUse.beard) e.beard = choiceWeighted(overlayManifest.facial_hair) || null;

  track.effects = e;
}

/* ---- Pose sanity (bbox-medveten) ---- */
function isValidPose(p, box){
  if (!p || !box) return false;
  const {x, y, width: w, height: h} = box;
  const ok = v => Number.isFinite(v);
  if (!ok(p.eyeCx)||!ok(p.eyeCy)||!ok(p.eyeD)) return false;

  const ex = p.eyeCx - x;
  const ey = p.eyeCy - y;

  const minEyeD = Math.max(6, Math.min(w,h)*0.06);
  const maxEyeD = Math.min(w*0.9, Math.min(w,h)*0.8);
  if (!(p.eyeD > minEyeD && p.eyeD < maxEyeD)) return false;

  if (ok(p.mouthW) && !(p.mouthW > minEyeD*0.6 && p.mouthW < w*1.2)) return false;

  if (!(ex >= -w*0.2 && ex <= w*1.2 && ey >= -h*0.2 && ey <= h*1.2)) return false;

  return true;
}

/* --------- Landmark-only rendering --------- */
function drawItem(meta, track, x,y,w,h){
  if(!meta) return;
  const path = `./img/${meta.file}`;
  const img = imgCache.get(path); if(!img) return;

  const iw = (img.width || img.naturalWidth || 1);
  const ih = (img.height || img.naturalHeight || 1);

  const mAsset = assetMeta[meta.file] || {};
  const cfg = { ...meta, ...mAsset };
  const fit = (cfg.fit || defaultFitForFile(cfg.file));
  const flipX = !!cfg.flipX;
  const rotWithEyes = (cfg.rot !== false);

  if (!track.usePose) return;

  const p = track.pose;
  let eyeC = {x:p.eyeCx, y:p.eyeCy};
  let eyeD = p.eyeD;
  if (!Number.isFinite(eyeC.x) || !Number.isFinite(eyeC.y) || !Number.isFinite(eyeD)) return;

  let angle= p.angle || 0;
  let mouthC = (p.mouthCx!=null && p.mouthCy!=null) ? {x:p.mouthCx, y:p.mouthCy} : {x:eyeC.x, y:eyeC.y + eyeD*0.6};
  const mouthW = p.mouthW || eyeD*0.9;
  const faceW  = p.faceW  || w;

  if (MIRROR){
    eyeC = { x: overlay.width - eyeC.x, y: eyeC.y };
    mouthC = { x: overlay.width - mouthC.x, y: mouthC.y };
    angle = -angle;
  }

  let cx, cy, refW, defWF=1.0, defY=0, defX=0;
  if (fit==='eyes' || fit==='glasses'){ cx=eyeC.x; cy=eyeC.y; refW=eyeD; defWF=(fit==='eyes')?2.2:2.0; defY=(fit==='eyes')?0.15:0.05; }
  else if (fit==='mouth'){ cx=mouthC.x; cy=mouthC.y; refW=mouthW; defWF=1.3; }
  else if (fit==='beard'){ cx=mouthC.x; cy=mouthC.y + eyeD*0.55; refW=faceW; defWF=0.9; defY=0.05; }
  else if (fit==='hat'){ cx=eyeC.x; cy=eyeC.y - eyeD*0.9; refW=faceW; defWF=1.1; defY=-0.15; }
  else { return; }

  const wf = (cfg.wFactor ?? defWF);
  const drawW = refW * wf;
  const drawH = drawW * (ih/iw);

  const dx = (cfg.xOffset || defX) * refW;
  const dy = ((cfg.yOffset !== undefined ? cfg.yOffset : defY)) * refW;

  ctx.save();
  if (rotWithEyes){
    ctx.translate(cx + dx, cy + dy);
    if (flipX) ctx.scale(-1,1);
    ctx.rotate(angle);
    ctx.drawImage(img, -drawW/2, -drawH/2, drawW, drawH);
  } else {
    const px = cx + dx - drawW/2, py = cy + dy - drawH/2;
    if (flipX){ ctx.translate(px+drawW/2, py+drawH/2); ctx.scale(-1,1); ctx.drawImage(img,-drawW/2,-drawH/2,drawW,drawH); }
    else ctx.drawImage(img, px, py, drawW, drawH);
  }
  ctx.restore();
}
function defaultFitForFile(path){
  if (path.startsWith('assets/glasses/'))     return 'glasses';
  if (path.startsWith('assets/eyes/'))        return 'eyes';
  if (path.startsWith('assets/mouth/'))       return 'mouth';
  if (path.startsWith('assets/facial_hair/')) return 'beard';
  if (path.startsWith('assets/hats/'))        return 'hat';
  return 'bbox';
}
function drawEffects(track,x,y,w,h){
  if(!overlaysEnabled || !track.effects) return;
  const e=track.effects;
  if (e.eyes)  drawItem(e.eyes,  track, x,y,w,h);
  if (e.glass) drawItem(e.glass, track, x,y,w,h);
  if (e.mouth) drawItem(e.mouth, track, x,y,w,h);
  if (e.beard) drawItem(e.beard, track, x,y,w,h);
  if (e.hat)   drawItem(e.hat,   track, x,y,w,h);
}

/* ---------- Kamera ---------- */
async function listCams(defaultIndex=0){
  const sel = document.getElementById('camSel');
  sel.innerHTML = '';
  try{
    const devices = (await navigator.mediaDevices.enumerateDevices()).filter(d => d.kind === 'videoinput');
    devices.forEach((d,i)=>{
      const o=document.createElement('option'); o.value=d.deviceId||''; o.textContent=d.label||`Kamera ${i+1}`; sel.appendChild(o);
    });
    if (!sel.value && devices.length) sel.selectedIndex = Math.min(defaultIndex, devices.length-1);
  }catch(e){ if (DEBUG) console.warn('[MoodCam] enumerateDevices fel', e); }
}
async function startCamera(deviceId){
  try{
    if (currentStream) currentStream.getTracks().forEach(t => t.stop());
    const base = { width:{ideal:1280}, height:{ideal:720}, frameRate:{ideal:30}, facingMode:'user' };
    const constraints = { audio:false, video: deviceId ? { ...base, deviceId:{ exact: deviceId } } : base };
    currentStream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = currentStream;
    await new Promise(r=>{ const f=()=>{video.removeEventListener('loadedmetadata',f); r();}; if(video.readyState>=1) r(); else video.addEventListener('loadedmetadata',f); });
    await video.play().catch(()=>{});
    syncOverlaySize();
    return true;
  }catch(err){
    console.error('[MoodCam] getUserMedia failed', err);
    alert('Kunde inte starta kameran.\n' + (err.name?`${err.name}: `:'') + (err.message||'Ok√§nt fel.') + '\nTips: k√∂r √∂ver HTTPS/localhost och st√§ng andra appar som anv√§nder kameran.');
    return false;
  }
}

/* ---------- Modeller ---------- */
let modelsPromise=null;
function ensureModelsLoading(){
  if (modelsPromise) return modelsPromise;
  modelsPromise = (async ()=>{
    console.info('[MoodCam] Laddar modeller ‚Ä¶');
    console.time('[MoodCam] Modeller klara');
    try{
      const base='./models/';
      await faceapi.nets.tinyFaceDetector.load(base);
      await faceapi.nets.faceExpressionNet.load(base);
      await faceapi.nets.ageGenderNet.load(base);
      try{
        await faceapi.nets.faceLandmark68Net.load(base);
        LANDMARKS_AVAILABLE=true;
        console.info('[MoodCam] Landmarks aktiverade');
      }catch(e){
        LANDMARKS_AVAILABLE=false;
        if (DEBUG) console.warn('[MoodCam] Landmarks kunde inte laddas:', e);
      }
      console.timeEnd('[MoodCam] Modeller klara');
      return true;
    }catch(e){
      console.error('[MoodCam] Kunde inte l√§sa in modeller', e);
      alert('Kunde inte l√§sa in AI-modellerna fr√•n /models/. Kontrollera att mappen /models/ finns och att filerna √§r √•tkomliga.');
      return false;
    }
  })();
  return modelsPromise;
}

/* ---------- Huvudloop (optimerad + anti-blink) ---------- */
async function tick(){
  try{
    scheduleResetIfNeeded();
    FRAME_I++;

    const now = performance.now();
    const dt = Math.min(0.1, (now - lastFrameTime)/1000); lastFrameTime = now;

    if (FRAME_OPTS.ADAPTIVE_INPUT) {
      if ((window.__lastFaceCount||0) >= FRAME_OPTS.MANY_FACES_THRESHOLD && DETECTOR_SIZE > FRAME_OPTS.LOW_INPUT_SIZE) {
        DETECTOR_SIZE = FRAME_OPTS.LOW_INPUT_SIZE;
        const isel = document.getElementById('inputSize'); if (isel) isel.value = DETECTOR_SIZE;
      }
    }

    const options = new faceapi.TinyFaceDetectorOptions({ inputSize: DETECTOR_SIZE, scoreThreshold: 0.65 });

    const doLandmarks = LANDMARKS_AVAILABLE && (FRAME_I % FRAME_OPTS.LANDMARK_EVERY === 0 || overlaysEnabled);
    const doAttrs     = (FRAME_I % FRAME_OPTS.ATTR_EVERY === 0);
    const doAge       = doAttrs && (FRAME_I % FRAME_OPTS.AGE_EVERY === 0);

    tf.engine().startScope();
    let builder = faceapi.detectAllFaces(video, options);
    if (doLandmarks && typeof builder.withFaceLandmarks === 'function') builder = builder.withFaceLandmarks();
    if (doAttrs)   builder = builder.withFaceExpressions();
    if (doAge)     builder = builder.withAgeAndGender();

    const detsFull = await builder;
    tf.engine().endScope();
    await tf.nextFrame();

    const dets = detsFull
      .slice()
      .sort((a,b)=> (b.detection.box.width*b.detection.box.height) - (a.detection.box.width*a.detection.box.height))
      .slice(0, MAX_FACES);

    if (dets.length > 0) lastNonEmptyTs = now; // anti-blink: uppdatera senaste "icke-tom"

    window.__lastFaceCount = dets.length;

    let frameHappyAdd = 0;

    ctx.clearRect(0,0,overlay.width,overlay.height);

    const DRAW_OVERLAYS_NOW = (dets.length <= FRAME_OPTS.MANY_FACES_THRESHOLD) ||
                              (FRAME_I % FRAME_OPTS.DRAW_OVERLAYS_EVERY === 0);

    for (const det of dets){
      const b = det.detection.box; const bbox=[b.x,b.y,b.width,b.height];

      // matchning + smoothing
      let best=null, bestIoU=0;
      for(const t of tracks){ const i=iou(t.bbox,bbox); if(i>bestIoU){bestIoU=i; best=t;} }
      if(best && bestIoU>0.3){
        const pb=best.bbox;
        best.bbox = pb
          ? [ema(pb[0], bbox[0], BBOX_POS_ALPHA),
             ema(pb[1], bbox[1], BBOX_POS_ALPHA),
             ema(pb[2], bbox[2], BBOX_SIZE_ALPHA),
             ema(pb[3], bbox[3], BBOX_SIZE_ALPHA)]
          : bbox.slice();
        best.last=now;
      } else {
        const t={ id:nextId++, bbox, last:now, created:now, seenFrames:0, counted:false,
                  peppText:null, ageHist:[], warm:0, contributing:false, effects:null, pose:{},
                  usePose:false, poseValid:0, poseInvalid:0, emo:'neutral', emoConf:0, lastAge:null };
        tracks.push(t); if(overlaysEnabled) assignEffects(t);
      }
      const tr=(best && bestIoU>0.3)? best : tracks[tracks.length-1];

      // Pose ‚Äì uppdatera endast n√§r vi har landmarks
      if (doLandmarks && det.landmarks){
        const lm = det.landmarks;
        const mean = pts => { const n=pts.length; const s=pts.reduce((a,p)=>({x:a.x+p.x,y:a.y+p.y}),{x:0,y:0}); return {x:s.x/n,y:s.y/n}; };
        const dist = (a,b)=> Math.hypot(a.x-b.x,a.y-b.y);
        const mid  = (a,b)=> ({x:(a.x+b.x)/2, y:(a.y+b.y)/2});

        const Leye = mean(lm.getLeftEye());
        const Reye = mean(lm.getRightEye());
        const eyeC = mid(Leye, Reye);
        const eyeD = dist(Leye, Reye);
        const angle= Math.atan2(Reye.y - Leye.y, Reye.x - Leye.x);

        const mouth = lm.getMouth?.();
        const mL = mouth ? mouth[0] : null;
        const mR = mouth ? mouth[6] : null;
        const mouthC = (mL && mR) ? mid(mL, mR) : null;
        const mouthW = (mL && mR) ? dist(mL, mR) : null;

        const jaw = lm.getJawOutline?.();
        const faceW = jaw ? dist(jaw[0], jaw[16]) : null;

        const pz = tr.pose;
        pz.eyeCx   = ema(pz.eyeCx,   eyeC.x, POSE_ALPHA);
        pz.eyeCy   = ema(pz.eyeCy,   eyeC.y, POSE_ALPHA);
        pz.eyeD    = ema(pz.eyeD,    eyeD,   POSE_ALPHA);
        pz.angle   = ema(pz.angle,   angle,  POSE_ALPHA);
        if (mouthC){ pz.mouthCx = ema(pz.mouthCx, mouthC.x, POSE_ALPHA); pz.mouthCy = ema(pz.mouthCy, mouthC.y, POSE_ALPHA); }
        if (mouthW!=null) pz.mouthW = ema(pz.mouthW, mouthW, POSE_ALPHA);
        if (faceW!=null)  pz.faceW  = ema(pz.faceW,  faceW,  POSE_ALPHA);

        const validNow = isValidPose(tr.pose, {x:b.x, y:b.y, width:b.width, height:b.height});
        if (validNow) { tr.poseValid++; tr.poseInvalid=0; if(!tr.usePose && tr.poseValid>=2) tr.usePose=true; }
        else          { tr.poseInvalid++; tr.poseValid=0; if(tr.usePose && tr.poseInvalid>=6) tr.usePose=false; }
      }

      // K√§nslor/√•lder (glesare); cacha i track
      let emo = tr.emo, conf = tr.emoConf;
      if (doAttrs && det.expressions){
        const exp=det.expressions||{};
        emo=null; conf=0; for(const [k,v] of Object.entries(exp)) if(v>conf){ emo=k; conf=v; }
        tr.emo = emo; tr.emoConf = conf;
      }
      const latestAge = doAge ? (det.age ?? null) : null;
      if (latestAge != null) tr.lastAge = latestAge;
      const shownAge = getSmoothedAge(tr, now, latestAge);

      // --- Glad-bidrag m. warmup ---
      if (emo === 'happy' && conf >= EMO_CONF_MIN) {
        tr.warm = Math.min(HAPPY_WARMUP_SECONDS, (tr.warm || 0) + dt);
        if (tr.warm >= HAPPY_WARMUP_SECONDS) {
          if (!tr.counted) {
            const key=todayKey();
            visitorsByDay[key]=(visitorsByDay[key]||0)+1;
            localStorage.setItem('moodcam.visitors', JSON.stringify(visitorsByDay));
            updateLogInfo();
            tr.counted = true;
          }
          tr.contributing = true;
          const weight = CONTRIB_WEIGHT_BY_CONF ? conf : 1;
          frameHappyAdd += dt * weight;
        }
      } else {
        tr.warm = Math.max(0, (tr.warm || 0) - dt * 0.5);
        tr.contributing = false;
      }

      const [bx,by,bw,bh]=tr.bbox;
      const rx = mirrorX(bx, bw);
      const color=EMO_COLOR[emo]||'#24ff78';

      // 1) overlays (glesare vid m√•nga ansikten)
      if (DRAW_OVERLAYS_NOW) drawEffects(tr, bx,by,bw,bh);

      // 2) face box + etikett
      if (SHOW_FACE_BOX) { ctx.strokeStyle=color; ctx.lineWidth=UI.faceBoxWidth; ctx.strokeRect(rx,by,bw,bh); }
      if(emo && conf>=EMO_CONF_MIN){
        const label=`${EMO_SV[emo]||emo} ¬∑ ${Math.round(conf*100)}%` + (shownAge?` ¬∑ ${shownAge} √•r`:'');
        drawLabel(rx,by,label);
      } else if(shownAge){ drawLabel(rx,by,`${shownAge} √•r`); }

      // 3) emoji
      const emoji=EMO_EMOJI[emo]||"üôÇ"; const emSize=Math.max(28, Math.round(Math.min(bw,bh)*0.22));
      ctx.font=`${emSize}px serif`; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(emoji, rx + bw, by);

      // 4) pepp
      if (peppEnabled){
        if(!tr.peppText) tr.peppText = randomPepp();
        drawCenteredBottom(rx,by,bw,bh,tr.peppText);
      }
    }

    // --- Anti-blink: om denna frame saknar ansikten, rita kvarvarande sp√•r en kort stund med fade ---
    if (dets.length === 0) {
      const remain = EMPTY_HYST_MS - (now - lastNonEmptyTs);
      if (remain > 0) {
        const alpha = Math.max(0, Math.min(1, remain / EMPTY_HYST_MS));
        ctx.save();
        ctx.globalAlpha = alpha;
        for (const tr of tracks) {
          if ((now - tr.last) <= EMPTY_HYST_MS) {
            const [bx,by,bw,bh] = tr.bbox;
            const rx = mirrorX(bx, bw);
            const emo = tr.emo ?? 'neutral';
            const conf = tr.emoConf ?? 0;
            const color = EMO_COLOR[emo] || '#24ff78';

            // Overlays (kan ritas √§ven h√§r)
            drawEffects(tr, bx,by,bw,bh);

            // Face box + etikett (respektera togglen)
            if (SHOW_FACE_BOX) { ctx.strokeStyle=color; ctx.lineWidth=UI.faceBoxWidth; ctx.strokeRect(rx,by,bw,bh); }
            if (emo && conf >= EMO_CONF_MIN) {
              const shownAge = getSmoothedAge(tr, now, null);
              const label = `${EMO_SV[emo]||emo} ¬∑ ${Math.round(conf*100)}%` + (shownAge?` ¬∑ ${shownAge} √•r`:'');
              drawLabel(rx,by,label);
            }

            // Emoji
            const emoji = EMO_EMOJI[emo] || "üôÇ";
            const emSize = Math.max(28, Math.round(Math.min(bw,bh)*0.22));
            ctx.font=`${emSize}px serif`; ctx.textAlign='center'; ctx.textBaseline='middle';
            ctx.fillText(emoji, rx + bw, by);

            // Pepp
            if (peppEnabled) drawCenteredBottom(rx,by,bw,bh, tr.peppText || '');
          }
        }
        ctx.restore();
      }
    }

    // gladtid
    HAPPY_PERSON_SECONDS += frameHappyAdd;

    // st√§da sp√•r
    const tnow=performance.now(); for(let i=tracks.length-1;i>=0;i--) if(tnow-tracks[i].last>1500) tracks.splice(i,1);

    // m√§tare
    const targetPct = Math.min(100, 100*(HAPPY_PERSON_SECONDS/METER_GOAL_SECONDS));
    meterShown = meterShown + (targetPct - meterShown) * METER_EASE;
    document.getElementById('meterFill').style.width = Math.max(0,Math.min(100,meterShown)) + '%';
    document.getElementById('meterVal').textContent = Math.round(meterShown);
  } catch(err){
    console.error('[MoodCam] tick() error:', err);
  }
  requestAnimationFrame(tick);
}

/* ---------- Logg / CSV ---------- */
function updateLogInfo(){ const list=Object.entries(visitorsByDay).sort(([a],[b])=>a.localeCompare(b)); const txt=list.length? list.map(([d,n])=>`${d}: ${n}`).join(' ¬∑ ') : 'Ingen logg √§n.'; const el=document.getElementById('logInfo'); if(el) el.textContent=txt; }
function downloadCSV(){ const rows=[['date','visitors'],...Object.entries(visitorsByDay)]; const csv=rows.map(r=>r.join(',')).join('\n'); const blob=new Blob([csv],{type:'text/csv'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='moodcam_visitors.csv'; a.click(); URL.revokeObjectURL(a.href); }

/* ---------- Init ---------- */
(async function init(){
  console.info('[MoodCam] Init‚Ä¶ TFJS:', (tf && tf.version_core)||'n/a', 'face-api:', (faceapi && faceapi.version)||'n/a');

  // Backend: f√∂rs√∂k GPU/WebGL f√∂rst, sedan WASM
  try {
    await tf.setBackend('webgl'); await tf.ready();
    console.info('[MoodCam] TF backend:', tf.getBackend());
  } catch(e) {
    console.warn('[MoodCam] WebGL misslyckades, provar WASM:', e);
    try { await tf.setBackend('wasm'); await tf.ready(); console.info('[MoodCam] TF backend:', tf.getBackend()); } catch(e2){ console.warn('[MoodCam] WASM misslyckades ocks√•:', e2); }
  }

  const wrap=document.getElementById('wrap');
  video=document.getElementById('video'); overlay=document.getElementById('overlay'); ctx=overlay.getContext('2d');

  // UI handlers
  document.getElementById('settingsBtn').addEventListener('click', ()=>{ const s=document.getElementById('settings'); s.style.display=(s.style.display==='none'||!s.style.display)?'block':'none'; });
  document.getElementById('conf').addEventListener('input', e=> EMO_CONF_MIN=parseFloat(e.target.value));
  document.getElementById('inputSize').addEventListener('input', e=> DETECTOR_SIZE=parseInt(e.target.value,10));
  document.getElementById('peppToggle').addEventListener('change', e=> { peppEnabled=e.target.checked; });
  document.getElementById('peppCat').addEventListener('change', e=> { peppCat=e.target.value; });

  ['fBrightness','fContrast','fSaturate','fHue','fTemp'].forEach(id=>{
    document.getElementById(id).addEventListener('input', ()=>{
      video.style.filter =
        `brightness(${fBrightness.value}%) contrast(${fContrast.value}%) saturate(${fSaturate.value}%) hue-rotate(${fHue.value}deg)` +
        ((+fTemp.value!==0)?` sepia(${Math.max(0,+fTemp.value)*0.006}) hue-rotate(${(+fTemp.value*1.2).toFixed(1)}deg) saturate(${(100 + +fTemp.value*0.2).toFixed(1)}%)`:'');
    });
  });
  document.getElementById('filtersReset').addEventListener('click', ()=>{
    fBrightness.value=100; fContrast.value=100; fSaturate.value=100; fHue.value=0; fTemp.value=0;
    const evt=new Event('input'); fBrightness.dispatchEvent(evt);
  });
  fBrightness.dispatchEvent(new Event('input'));

  // Spegelv√§nd toggle ‚Äì bara video f√•r klass, och vi s√§tter flaggan f√∂r ritkompensation
  document.getElementById('mirrorX').addEventListener('change', e=>{
    MIRROR = e.target.checked;
    if (MIRROR) wrap.classList.add('mirror'); else wrap.classList.remove('mirror');
  });

  // Visa/d√∂lj ansiktsruta
  const showBoxEl = document.getElementById('showBox');
  showBoxEl.checked = SHOW_FACE_BOX;
  showBoxEl.addEventListener('change', e=>{ SHOW_FACE_BOX = e.target.checked; });

  const themeSel = document.getElementById('themeSel');
  THEMES.forEach(t=>{ const o=document.createElement('option'); o.value=t; o.textContent=t; themeSel.appendChild(o); });
  themeSel.value = selectedTheme;
  themeSel.addEventListener('change', async e=>{
    selectedTheme = e.target.value;
    if (overlaysEnabled) { await loadOverlayManifest(selectedTheme); tracks.forEach(t=>assignEffects(t)); }
  });

  document.getElementById('overlayToggle').addEventListener('change', async e=> {
    overlaysEnabled=e.target.checked;
    if (overlaysEnabled && !overlayManifest) await loadOverlayManifest(selectedTheme);
    tracks.forEach(t=>assignEffects(t));
  });
  document.getElementById('ovHats').addEventListener('change', e=> { overlayUse.hats=e.target.checked; tracks.forEach(t=>assignEffects(t)); });
  document.getElementById('ovGlasses').addEventListener('change', e=> { overlayUse.glasses=e.target.checked; tracks.forEach(t=>assignEffects(t)); });
  document.getElementById('ovEyes').addEventListener('change', e=> { overlayUse.eyes=e.target.checked; tracks.forEach(t=>assignEffects(t)); });
  document.getElementById('ovMouth').addEventListener('change', e=> { overlayUse.mouth=e.target.checked; tracks.forEach(t=>assignEffects(t)); });
  document.getElementById('ovBeard').addEventListener('change', e=> { overlayUse.beard=e.target.checked; tracks.forEach(t=>assignEffects(t)); });

  document.getElementById('dlLog').addEventListener('click', downloadCSV);
  document.getElementById('clearLog').addEventListener('click', ()=> { localStorage.setItem('moodcam.visitors','{}'); for (const k in visitorsByDay) delete visitorsByDay[k]; updateLogInfo(); });

  const goalInput=document.getElementById('goalSec'); const goalLabel=document.getElementById('goalLabel');
  METER_GOAL_SECONDS=parseInt(goalInput.value,10); goalLabel.textContent=METER_GOAL_SECONDS;
  goalInput.addEventListener('input', e=>{ METER_GOAL_SECONDS=parseInt(e.target.value,10); goalLabel.textContent=METER_GOAL_SECONDS; });

  await loadAssetMeta();
  await loadPepp();
  listCams(1);
  ensureModelsLoading();

  document.getElementById('start').addEventListener('click', async ()=>{
    const modelsOK = await ensureModelsLoading(); if (!modelsOK) return;
    const sel=document.getElementById('camSel');
    const ok = await startCamera(sel.value); if (!ok) return;

    new ResizeObserver(()=>{
      overlay.width=video.videoWidth; overlay.height=video.videoHeight;
      overlay.style.width=video.clientWidth+'px'; overlay.style.height=video.clientHeight+'px';
    }).observe(document.getElementById('wrap'));
    console.info('[MoodCam] Kamera ig√•ng, startar loop‚Ä¶');
    requestAnimationFrame(tick);
    document.getElementById('start').disabled = true;
  });

  window.addEventListener('error', (e)=> console.error('[MoodCam] window error:', e.error||e.message));
})();
</script>
</body>
</html>
