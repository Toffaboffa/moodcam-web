<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>MoodCam (web)</title>
  <style>
    html,body{margin:0;height:100%;background:#0b0f14;color:#e7effa;font-family:system-ui,Segoe UI,Roboto,sans-serif}
    #stage{display:grid;place-items:center;height:100%}
    /* Viktigt: omslag runt video+canvas måste vara relativt placerat */
    .layer-wrap{
      position:relative; display:inline-block; border-radius:12px; overflow:hidden;
      box-shadow:0 12px 36px rgba(0,0,0,.5);
      max-width:96vw; max-height:96vh;
    }
    video{display:block; width:100%; height:auto;}
    /* Canvas ligger ovanpå videon */
    canvas{
      position:absolute; inset:0; width:100%; height:100%;
      pointer-events:none; /* klick går igenom */
    }
    .warn{position:fixed;left:10px;bottom:10px;font-size:12px;opacity:.65}
    .btn{position:fixed;top:10px;left:10px;background:#111827;border:1px solid #1f2937;color:#e7effa;
         padding:8px 12px;border-radius:8px;cursor:pointer}
    .btn:disabled{opacity:.5;cursor:not-allowed}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.21.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api/dist/face-api.min.js"></script>
</head>
<body>
<button id="start" class="btn">Starta kamera</button>
<div id="stage">
  <div class="layer-wrap" id="wrap">
    <video id="video" autoplay muted playsinline></video>
    <canvas id="overlay"></canvas>
  </div>
</div>
<div class="warn">Ge kameratillstånd i webbläsaren. Allt körs lokalt i din dator.</div>

<script>
const EMO_SV = {angry:"Arg", disgust:"Äcklad", fear:"Rädd", happy:"Glad", sad:"Ledsen", surprise:"Förvånad", neutral:"Neutral"};
const EMO_COLOR = {happy:"#28c728", angry:"#2a2ae0", sad:"#c07800", surprise:"#c0c000", fear:"#00b4b4", disgust:"#00a078", neutral:"#b0b0b0"};
const EMO_CONF_MIN = 0.40;

async function loadModels() {
  const base = './models/';               // relativ sökväg för GitHub Pages
  await faceapi.nets.tinyFaceDetector.load(base);
  await faceapi.nets.faceExpressionNet.load(base);
  await faceapi.nets.ageGenderNet.load(base); // vi använder bara age
}

function drawLabel(ctx, x, y, text) {
  ctx.font = '16px system-ui';
  const pad = 6, h = 18, w = ctx.measureText(text).width;
  ctx.fillStyle = 'rgba(0,0,0,0.85)';
  ctx.fillRect(x - pad, y - h - pad, w + pad*2, h + pad*2);
  ctx.fillStyle = '#fff';
  ctx.fillText(text, x, y);
}

// Håll canvas i exakt samma pixelstorlek som videons buffer
function syncOverlaySize(video, canvas) {
  // Intern bitmap-storlek (viktig för ritkoordinater)
  canvas.width  = video.videoWidth;
  canvas.height = video.videoHeight;
  // Visuell storlek (följer videon i layouten)
  canvas.style.width  = video.clientWidth + 'px';
  canvas.style.height = video.clientHeight + 'px';
}

async function start() {
  const btn = document.getElementById('start');
  btn.disabled = true;
  try {
    await loadModels();

    const video = document.getElementById('video');
    const overlay = document.getElementById('overlay');

    const stream = await navigator.mediaDevices.getUserMedia({
      video: { width: { ideal: 960 }, height: { ideal: 540 } }
    });
    video.srcObject = stream;

    await new Promise(r => video.onloadedmetadata = r);
    syncOverlaySize(video, overlay);

    // Uppdatera om fönstret ändrar storlek
    new ResizeObserver(() => syncOverlaySize(video, overlay)).observe(document.getElementById('wrap'));

    const ctx = overlay.getContext('2d');
    const options = new faceapi.TinyFaceDetectorOptions({ inputSize: 320, scoreThreshold: 0.6 });

    async function tick() {
      const detections = await faceapi
        .detectAllFaces(video, options)
        .withFaceExpressions()
        .withAgeAndGender();

      ctx.clearRect(0,0,overlay.width,overlay.height);

      for (const det of detections) {
        const { x, y, width, height } = det.detection.box;

        // toppemotion + konfidens
        const emotions = det.expressions || {};
        let emo = null, conf = 0;
        for (const [k,v] of Object.entries(emotions)) if (v > conf) { emo = k; conf = v; }

        const age = det.age ? Math.round(det.age) : null;

        const color = EMO_COLOR[emo] || '#24ff78';
        ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.strokeRect(x, y, width, height);

        if (emo && conf >= EMO_CONF_MIN) {
          const label = `${EMO_SV[emo] || emo} · ${Math.round(conf*100)}%` + (age ? ` · ${age} år` : '');
          drawLabel(ctx, x, y, label);
        } else if (age) {
          drawLabel(ctx, x, y, `${age} år`);
        }
      }
      requestAnimationFrame(tick);
    }
    tick();
  } catch (err) {
    alert('Kunde inte starta: ' + err);
    console.error(err);
    document.getElementById('start').disabled = false;
  }
}

document.getElementById('start').addEventListener('click', start);
</script>
</body>
</html>
